<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Virtual DOM + Scripts + Proxy + DevTools</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      font-family: sans-serif;
      background: #181818;
      color: #eee;
    }
    #toolbar {
      padding: 8px 10px;
      background: #222;
      display: flex;
      gap: 10px;
      align-items: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    #urlInput {
      flex: 1;
      padding: 6px 8px;
      border: none;
      border-radius: 4px;
      font-size: 14px;
    }
    button {
      padding: 6px 14px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      background: #444;
      color: #fff;
      font-size: 14px;
      transition: background 0.2s;
    }
    button:hover {
      background: #666;
    }
    canvas {
      display: block;
      flex: 1;
    }

    /* --- DevTools --- */
    #devPanel {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(20,20,20,0.95);
      color: #eee;
      font-family: Consolas, monospace;
      font-size: 13px;
      padding: 8px;
      max-height: 330px;
      overflow-y: auto;
      display: none;
      z-index: 1000;
      border-top: 2px solid #444;
    }
    #devPanelHeader {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      align-items: center;
    }
    .devTabBtn {
      font-size: 12px;
      padding: 4px 10px;
      background: #333;
      border: none;
      border-radius: 4px;
    }
    .devTabBtn:hover {
      background: #555;
    }
    #inspectorView, #statusView {
      margin-top: 6px;
    }
    #statusView {
      display: none; /* Oculto por defecto, tab "Inspector" se ve primero */
    }
    /* Inspector Tree */
    #treeView ul {
      list-style: none;
      margin-left: 20px;
      padding-left: 10px;
      border-left: 1px dotted #555;
    }
    #treeView li {
      margin: 4px 0;
    }
    #treeView span {
      cursor: text;
    }
    #treeView .attrLabel {
      margin-left: 4px;
    }
    #treeView .attrInput {
      outline: 1px dashed transparent;
      padding: 0 3px;
      border-radius: 3px;
      display: inline-block;
      white-space: pre;
      margin-right: 2px;
    }
    #treeView .attrInput:focus {
      outline: 1px dashed #66f;
      background: #222;
    }
    #treeView .actionBtn {
      margin-left: 8px;
      font-size: 11px;
      padding: 1px 4px;
      cursor: pointer;
    }
  </style>
  <!-- Import map para Three.js -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three/build/three.module.js",
        "three/addons/": "https://unpkg.com/three/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <!-- Barra Superior -->
  <div id="toolbar">
    <input id="urlInput" type="text" placeholder="Ingrese URL de HSML" value="/static/main.hsml">
    <button id="loadButton">Cargar HSML</button>
    <button id="toggleDevPanel">Mostrar DevTools</button>
  </div>

  <!-- Lienzo principal de Three.js -->
  <canvas id="canvas"></canvas>

  <!-- Panel de Desarrollo -->
  <div id="devPanel">
    <div id="devPanelHeader">
      <!-- Pestañas -->
      <button id="inspectorTabBtn" class="devTabBtn">Inspector</button>
      <button id="statusTabBtn" class="devTabBtn">Status</button>

      <!-- Botones de Cámara libre y Iluminación -->
      <button id="toggleFreeCameraBtn" class="devTabBtn">Activar Cámara Libre</button>
      <button id="toggleLightingBtn" class="devTabBtn">Desactivar Iluminación</button>
    </div>

    <!-- Vista Inspector -->
    <div id="inspectorView">
      <strong>Árbol Virtual HSML</strong>
      <div id="treeView"></div>
    </div>

    <!-- Vista Status -->
    <div id="statusView">
      <strong>Estado del Render</strong>
      <div style="margin-top: 4px;">
        <div>FPS: <span id="fpsValue">0</span></div>
        <div>Memoria: <span id="ramValue">N/A</span></div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

    // ========== 0) Variables y clases globales ==========
    class VirtualNode {
      constructor(tag) {
        this.tag = tag;
        this.attributes = {};
        this.children = [];
        this.key = VirtualNode.nextKey++;
      }
      setAttribute(attr, value) {
        this.attributes[attr] = value;
      }
      appendChild(child) {
        this.children.push(child);
      }
    }
    VirtualNode.nextKey = 1;

    let virtualDOM = null;
    const nodeKeyToObject = new Map();
    const userUpdateFunctions = [];

    // Control de FPS
    let lastTime = performance.now();
    let frames = 0;
    let currentFPS = 0;

    // Iluminación
    let lightingEnabled = false;

    // ========== 1) Proxy de VirtualNode, con notificación al DevTool ==========
    let devtoolDirty = false;    // Indica si se debe refrescar el Inspector
    let lastDevtoolUpdate = 0;   // Último momento de refresh
    const DEVTOOL_THROTTLE_MS = 100;

    function scheduleDevToolUpdate() {
      devtoolDirty = true;
    }

    function maybeUpdateDevTool() {
      if (!devtoolDirty) return;
      const now = performance.now();
      if (now - lastDevtoolUpdate >= DEVTOOL_THROTTLE_MS) {
        updateDevTool();
        devtoolDirty = false;
        lastDevtoolUpdate = now;
      }
    }

    function createProxiedNode(tag) {
      const realNode = new VirtualNode(tag);
      return new Proxy(realNode, {
        get(target, prop, receiver) {
          // position
          if (prop === 'position') {
            return {
              get x() { return parseFloat(target.attributes.x ?? 0); },
              set x(val) { target.setAttribute('x', val); scheduleDevToolUpdate(); },
              get y() { return parseFloat(target.attributes.y ?? 0); },
              set y(val) { target.setAttribute('y', val); scheduleDevToolUpdate(); },
              get z() { return parseFloat(target.attributes.z ?? 0); },
              set z(val) { target.setAttribute('z', val); scheduleDevToolUpdate(); }
            };
          }
          // rotation
          if (prop === 'rotation') {
            return {
              get x() { return parseFloat(target.attributes.rx ?? 0); },
              set x(val) { target.setAttribute('rx', val); scheduleDevToolUpdate(); },
              get y() { return parseFloat(target.attributes.ry ?? 0); },
              set y(val) { target.setAttribute('ry', val); scheduleDevToolUpdate(); },
              get z() { return parseFloat(target.attributes.rz ?? 0); },
              set z(val) { target.setAttribute('rz', val); scheduleDevToolUpdate(); }
            };
          }
          // appendChild
          if (prop === 'appendChild') {
            return (childProxy) => {
              target.children.push(childProxy);
            };
          }
          // setAttribute
          if (prop === 'setAttribute') {
            return (attr, val) => {
              target.setAttribute(attr, val);
              scheduleDevToolUpdate();
            };
          }
          // Atributos directos
          if (prop in target.attributes) {
            return target.attributes[prop];
          }
          return Reflect.get(target, prop, receiver);
        },
        set(target, prop, value) {
          if (['src','class','collider','rigidbody','id','scale','x','y','z','rx','ry','rz']
              .includes(prop)) {
            target.setAttribute(prop, value);
            scheduleDevToolUpdate();
            return true;
          }
          return Reflect.set(target, prop, value);
        }
      });
    }

    // ========== 2) Convertir HSML en VirtualNode ==========
    function parseHSML(xmlNode) {
      if (!xmlNode || xmlNode.nodeType !== Node.ELEMENT_NODE) return null;
      const vnode = new VirtualNode(xmlNode.nodeName);
      for (let i = 0; i < xmlNode.attributes.length; i++) {
        const attr = xmlNode.attributes[i];
        vnode.setAttribute(attr.name, attr.value);
      }
      Array.from(xmlNode.childNodes).forEach(child => {
        const childVNode = parseHSML(child);
        if (childVNode) vnode.appendChild(childVNode);
      });
      return vnode;
    }

    // ========== 3) Construir la escena solo 1 vez por nodo ==========
    function buildSceneFromVirtual(vnode, parentObj) {
      let obj;
      if (vnode.tag === "model") {
        obj = new THREE.Object3D();
        const src = vnode.attributes.src;
        if (src) {
          const loader = new GLTFLoader();
          loader.load(
            src,
            gltf => {
              while (obj.children.length > 0) obj.remove(obj.children[0]);
              obj.add(gltf.scene);
            },
            undefined,
            err => console.error("Error al cargar modelo:", src, err)
          );
        }
      } else {
        obj = new THREE.Object3D();
      }
      obj.userData.key = vnode.key;

      parentObj.add(obj);
      nodeKeyToObject.set(vnode.key, obj);

      vnode.children.forEach(child => {
        buildSceneFromVirtual(child, obj);
      });
    }

    // ========== 4) Aplicar transformaciones cada frame ==========
    function applyTransformsRecursively(vnode) {
      const obj = nodeKeyToObject.get(vnode.key);
      if (obj) {
        if (vnode.attributes.scale !== undefined) {
          const s = parseFloat(vnode.attributes.scale);
          if (!isNaN(s)) obj.scale.set(s, s, s);
        }
        const x = parseFloat(vnode.attributes.x ?? 0);
        const y = parseFloat(vnode.attributes.y ?? 0);
        const z = parseFloat(vnode.attributes.z ?? 0);
        obj.position.set(x, y, z);
        const rx = parseFloat(vnode.attributes.rx ?? 0);
        const ry = parseFloat(vnode.attributes.ry ?? 0);
        const rz = parseFloat(vnode.attributes.rz ?? 0);
        obj.rotation.set(rx, ry, rz);
      }
      vnode.children.forEach(child => applyTransformsRecursively(child));
    }

    // ========== 5) DevTools: Inspector / Árbol Virtual ==========
    function updateDevTool() {
      const treeView = document.getElementById('treeView');
      treeView.innerHTML = '';
      if (!virtualDOM) return;
      const domTree = buildVirtualTreeHTML(virtualDOM);
      if (domTree) treeView.appendChild(domTree);
    }

    function buildVirtualTreeHTML(vnode) {
      const li = document.createElement('li');
      const header = document.createElement('div');
      header.style.display = 'flex';
      header.style.flexWrap = 'wrap';
      header.style.alignItems = 'center';

      const tagSpan = document.createElement('span');
      tagSpan.textContent = `<${vnode.tag}>`;
      header.appendChild(tagSpan);

      for (const attrName in vnode.attributes) {
        const attrValue = vnode.attributes[attrName];
        const attrLabel = document.createElement('span');
        attrLabel.classList.add('attrLabel');
        attrLabel.textContent = ` ${attrName}="`;

        const attrInput = document.createElement('span');
        attrInput.classList.add('attrInput');
        attrInput.contentEditable = true;
        attrInput.textContent = attrValue;
        attrInput.addEventListener('blur', () => {
          const newVal = attrInput.textContent.trim();
          vnode.attributes[attrName] = newVal;
          scheduleDevToolUpdate();
        });

        attrLabel.appendChild(attrInput);
        const quoteSpan = document.createElement('span');
        quoteSpan.textContent = `"`;
        attrLabel.appendChild(quoteSpan);
        header.appendChild(attrLabel);
      }

      const centerBtn = document.createElement('button');
      centerBtn.textContent = "Centrar";
      centerBtn.classList.add('actionBtn');
      centerBtn.addEventListener('click', e => {
        e.stopPropagation();
        scene.traverse(obj => {
          if (obj.userData && obj.userData.key === vnode.key) {
            centerCameraOnObject(obj);
          }
        });
      });
      header.appendChild(centerBtn);

      const removeBtn = document.createElement('button');
      removeBtn.textContent = "Eliminar";
      removeBtn.classList.add('actionBtn');
      removeBtn.addEventListener('click', e => {
        e.stopPropagation();
        removeNodeByKey(virtualDOM, vnode.key);
        const obj = nodeKeyToObject.get(vnode.key);
        if (obj && obj.parent) obj.parent.remove(obj);
        nodeKeyToObject.delete(vnode.key);
        scheduleDevToolUpdate();
      });
      header.appendChild(removeBtn);

      li.appendChild(header);

      if (vnode.children.length > 0) {
        const ul = document.createElement('ul');
        vnode.children.forEach(child => {
          const childHTML = buildVirtualTreeHTML(child);
          if (childHTML) ul.appendChild(childHTML);
        });
        li.appendChild(ul);
      }
      return li;
    }

    function removeNodeByKey(rootVNode, key) {
      if (!rootVNode || !rootVNode.children) return false;
      for (let i = 0; i < rootVNode.children.length; i++) {
        if (rootVNode.children[i].key === key) {
          rootVNode.children.splice(i, 1);
          return true;
        } else {
          if (removeNodeByKey(rootVNode.children[i], key)) return true;
        }
      }
      return false;
    }

    function centerCameraOnObject(obj) {
      const pos = new THREE.Vector3();
      obj.getWorldPosition(pos);
      camera.position.set(pos.x, pos.y, pos.z + 5);
      camera.lookAt(pos);
    }

    let controller1, controller2;
    let controllerGrip1, controllerGrip2;

    // ========== 6) Three.js Setup ==========
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight - 40);

    renderer.setAnimationLoop( animate );

    // Habilitar WebXR para VR y agregar botón VR al toolbar
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.xr.enabled = true;
    renderer.xr.setReferenceSpaceType('local-floor');
    // o 'local' si no quieres anclar al piso
    // renderer.xr.setReferenceSpaceType('local');

    const vrButton = VRButton.createButton(renderer);
    document.getElementById('toolbar').appendChild(vrButton);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202020);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 20);
    renderer.xr.addEventListener('sessionstart', () => {
        // Por ejemplo, mover la escena un poco más lejos:
        camera.position.set(0, 5, 20);
    });
    window.addEventListener( 'resize', onWindowResize );

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );
    }

    function getTexturesFromAtlasFile( atlasImgUrl, tilesNum ) {
        const textures = [];

        for ( let i = 0; i < tilesNum; i ++ ) {
            textures[ i ] = new THREE.Texture();
        }

        const loader = new THREE.ImageLoader();
        loader.load( atlasImgUrl, function ( imageObj ) {

            let canvas, context;
            const tileWidth = imageObj.height;

            for ( let i = 0; i < textures.length; i ++ ) {

                canvas = document.createElement( 'canvas' );
                context = canvas.getContext( '2d' );
                canvas.height = tileWidth;
                canvas.width = tileWidth;
                context.drawImage( imageObj, tileWidth * i, 0, tileWidth, tileWidth, 0, 0, tileWidth, tileWidth );
                textures[ i ].colorSpace = THREE.SRGBColorSpace;
                textures[ i ].image = canvas;
                textures[ i ].needsUpdate = true;

            }

        } );

        return textures;
    }

    const geometry = new THREE.BoxGeometry( 100, 100, 100 );
    geometry.scale( 1, 1, - 1 );

    const textures = getTexturesFromAtlasFile( 'https://threejs.org/examples/textures/cube/sun_temple_stripe_stereo.jpg', 12 );

    const materials = [];

    for ( let i = 0; i < 6; i ++ ) {

        materials.push( new THREE.MeshBasicMaterial( { map: textures[ i ] } ) );

    }

    const skyBox = new THREE.Mesh( geometry, materials );
    scene.add( skyBox );


    // controllers

    function onSelectStart() {
        // this.userData.isSelecting = true;
    }

    function onSelectEnd() {
        // this.userData.isSelecting = false;
    }

    controller1 = renderer.xr.getController( 0 );
    controller1.addEventListener( 'selectstart', onSelectStart );
    controller1.addEventListener( 'selectend', onSelectEnd );
    controller1.addEventListener( 'connected', function ( event ) {
        this.add( buildController( event.data ) );
    });
    controller1.addEventListener( 'disconnected', function () {
        this.remove( this.children[ 0 ] );
    });
    scene.add( controller1 );

    controller2 = renderer.xr.getController( 1 );
    controller2.addEventListener( 'selectstart', onSelectStart );
    controller2.addEventListener( 'selectend', onSelectEnd );
    controller2.addEventListener( 'connected', function ( event ) {
        this.add( buildController( event.data ) );
    });
    controller2.addEventListener( 'disconnected', function () {
        this.remove( this.children[ 0 ] );
    });
    scene.add( controller2 );

    // ## Iluminacion

    const ambientLight = new THREE.AmbientLight(0xffffff, 3);
    if(lightingEnabled) scene.add(ambientLight);


    // ========== 7) Render Loop y FPS/Mem ==========
    function animate() {
    //   requestAnimationFrame(animate);

      userUpdateFunctions.forEach(fn => fn());
      if (virtualDOM) applyTransformsRecursively(virtualDOM);

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize( window.innerWidth, window.innerHeight );

      frames++;
      const now = performance.now();
      if (now - lastTime >= 1000) {
        currentFPS = frames * 1000 / (now - lastTime);
        frames = 0;
        lastTime = now;
        document.getElementById('fpsValue').textContent = currentFPS.toFixed(1);
        if (performance.memory) {
          const used = (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
          const total = (performance.memory.totalJSHeapSize / 1048576).toFixed(1);
          document.getElementById('ramValue').textContent = `${used} / ${total} MB`;
        }
      }
      maybeUpdateDevTool();
      renderer.render(scene, camera);
    }
    // animate();

    // ========== 8) Controles de cámara libre (WASD) ==========
    const keys = {};
    document.addEventListener('keydown', e => { keys[e.code] = true; });
    document.addEventListener('keyup', e => { keys[e.code] = false; });
    const moveSpeed = 0.2, rotationSpeed = 0.002;

    document.addEventListener('mousemove', e => {
      if (document.pointerLockElement === canvas) {
        camera.rotation.y -= e.movementX * rotationSpeed;
        camera.rotation.x -= e.movementY * rotationSpeed;
        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
      }
    });
    function updateCameraLoop() {
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();
      const right = new THREE.Vector3();
      right.crossVectors(camera.up, forward).normalize();
      if (keys['KeyW']) camera.position.addScaledVector(forward, moveSpeed);
      if (keys['KeyS']) camera.position.addScaledVector(forward, -moveSpeed);
      if (keys['KeyA']) camera.position.addScaledVector(right, moveSpeed);
      if (keys['KeyD']) camera.position.addScaledVector(right, -moveSpeed);
      requestAnimationFrame(updateCameraLoop);
    }
    updateCameraLoop();

    // ========== 9) dimension / setUpdate (expuestos al script) ==========
    const dimension = {
      createElement(tagName) {
        return createProxiedNode(tagName);
      },
      appendChild(childProxy) {
        if (!virtualDOM) {
          console.warn("No hay virtualDOM aún.");
          return;
        }
        virtualDOM.children.push(childProxy);
        buildSceneFromVirtual(childProxy, scene);
        scheduleDevToolUpdate();
      },
      refresh() {
        scheduleDevToolUpdate();
      }
    };

    function setUpdate(fn) {
      userUpdateFunctions.push(fn);
    }

    // ========== 10) Cargar HSML + Scripts en Sandbox ==========
    function loadHSML() {
      const url = document.getElementById('urlInput').value;
      fetch(url)
        .then(res => res.text())
        .then(hsmlString => {
          scene.clear();
          scene.add( skyBox );
          nodeKeyToObject.clear();
          VirtualNode.nextKey = 1;
          userUpdateFunctions.length = 0;

          const parser = new DOMParser();
          const xmlDoc = parser.parseFromString(hsmlString, "text/xml");
          const spaceXML = xmlDoc.getElementsByTagName("space")[0];
          if (!spaceXML) {
            console.error("No se encontró <space> en el HSML");
            return;
          }
          virtualDOM = parseHSML(spaceXML);
          buildSceneFromVirtual(virtualDOM, scene);
          scheduleDevToolUpdate();

          const scriptTags = spaceXML.getElementsByTagName("script");
          for (let i = 0; i < scriptTags.length; i++) {
            const scriptNode = scriptTags[i];
            const scriptURL = scriptNode.getAttribute("src");
            if (scriptURL) {
              fetch(scriptURL)
                .then(r => r.text())
                .then(code => {
                  const sandboxedFn = new Function(
                    "dimension",
                    "setUpdate",
                    "setTimeout",
                    "setInterval",
                    code
                  );
                  sandboxedFn(dimension, setUpdate, setTimeout, setInterval);
                })
                .catch(err => console.error("Error al cargar script:", scriptURL, err));
            }
          }
        })
        .catch(err => console.error("Error al cargar HSML:", err));
    }

    // ========== 11) Eventos de UI (pestañas, botones) ==========
    document.getElementById('loadButton').addEventListener('click', loadHSML);
    const devPanel = document.getElementById('devPanel');
    const toggleDevPanelBtn = document.getElementById('toggleDevPanel');
    toggleDevPanelBtn.addEventListener('click', () => {
      if (devPanel.style.display === 'none' || devPanel.style.display === '') {
        devPanel.style.display = 'block';
        toggleDevPanelBtn.textContent = 'Ocultar DevTools';
      } else {
        devPanel.style.display = 'none';
        toggleDevPanelBtn.textContent = 'Mostrar DevTools';
      }
    });

    const inspectorView = document.getElementById('inspectorView');
    const statusView = document.getElementById('statusView');
    document.getElementById('inspectorTabBtn').addEventListener('click', () => {
      inspectorView.style.display = 'block';
      statusView.style.display = 'none';
    });
    document.getElementById('statusTabBtn').addEventListener('click', () => {
      inspectorView.style.display = 'none';
      statusView.style.display = 'block';
    });

    const toggleFreeCameraBtn = document.getElementById('toggleFreeCameraBtn');
    toggleFreeCameraBtn.addEventListener('click', () => {
      if (document.pointerLockElement !== canvas) {
        canvas.requestPointerLock();
        toggleFreeCameraBtn.textContent = 'Desactivar Cámara Libre';
      } else {
        document.exitPointerLock();
        toggleFreeCameraBtn.textContent = 'Activar Cámara Libre';
      }
    });

    const toggleLightingBtn = document.getElementById('toggleLightingBtn');
    toggleLightingBtn.addEventListener('click', () => {
      lightingEnabled = !lightingEnabled;
      if (lightingEnabled) {
        scene.add(ambientLight);
        toggleLightingBtn.textContent = 'Desactivar Iluminación';
      } else {
        scene.remove(ambientLight);
        toggleLightingBtn.textContent = 'Activar Iluminación';
      }
    });
    if (lightingEnabled) {
      toggleLightingBtn.textContent = 'Desactivar Iluminación';
    } else {
      toggleLightingBtn.textContent = 'Activar Iluminación';
    }

    // setTimeout(loadHSML, 200)

  </script>
</body>
</html>
