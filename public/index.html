<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Framework V3.1 • Espacios Virtuales (HSML)</title>
  <style>
    :root { --bg:#181818; --fg:#eee; --panel:#222; --btn:#444; --btnH:#666; }
    body { margin:0; overflow:hidden; display:flex; flex-direction:column; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif; background:var(--bg); color:var(--fg); }
    #toolbar { padding:8px 10px; background:var(--panel); display:flex; gap:10px; align-items:center; box-shadow:0 2px 4px rgba(0,0,0,.5); position:relative; z-index:2; }
    #urlInput { flex:1; padding:6px 8px; border:none; border-radius:4px; font-size:14px; }
    button { padding:6px 14px; cursor:pointer; border:none; border-radius:4px; background:var(--btn); color:#fff; font-size:14px; transition:background .2s, transform .02s; }
    button:hover{ background:var(--btnH); }
    button:active{ transform:translateY(1px); }
    canvas { display:block; flex:1; }

    #devPanel { position:fixed; bottom:0; left:0; right:0; background:rgba(20,20,20,0.95); color:#eee; font-family:Consolas, monospace; font-size:13px; padding:8px; max-height:40vh; overflow-y:auto; display:none; z-index:5; border-top:2px solid #444; }
    #devPanelHeader { display:flex; gap:8px; margin-bottom:8px; align-items:center; flex-wrap:wrap; }
    .devTabBtn { font-size:12px; padding:4px 10px; background:#333; border:none; border-radius:4px; }
    .devTabBtn:hover{ background:#555; }
    #inspectorView, #statusView { margin-top:6px; }
    #statusView { display:none; }
    #treeView ul{ list-style:none; margin-left:20px; padding-left:10px; border-left:1px dotted #555; }
    #treeView li{ margin:4px 0; }
    #treeView .attrLabel{ margin-left:4px; }
    #treeView .attrInput{ outline:1px dashed transparent; padding:0 3px; border-radius:3px; display:inline-block; white-space:pre; margin-right:2px; }
    #treeView .attrInput:focus{ outline:1px dashed #66f; background:#222; }
    #smallNote { opacity:.8; font-size:11px; margin-left:auto; }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three/build/three.module.js",
        "three/addons/": "https://unpkg.com/three/examples/jsm/"
      }
    }
  </script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght@400" />
  <style>
    .material-symbols-outlined {
      font-variation-settings:
        'FILL' 0,
        'wght' 400,
        'GRAD' 0,
        'opsz' 24;
      vertical-align: middle;
      line-height: 1;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <input id="urlInput" type="text" placeholder="Pega HSML o URL (Enter)" value="">
    <button id="loadButton" title="Cargar HSML"><span class="material-symbols-outlined">folder_open</span></button>
    <button id="toggleDevPanel" title="DevTools"><span class="material-symbols-outlined">build</span></button>
    <button id="exportBtn" title="Exportar HSML"><span class="material-symbols-outlined">save</span></button>
    <button id="favAddBtn" title="Agregar a favoritos"><span class="material-symbols-outlined">star</span></button>
    <select id="favList" title="Favoritos" style="max-width:220px;"></select>
    <button id="favGoBtn" title="Abrir favorito"><span class="material-symbols-outlined">arrow_forward</span></button>
    <button id="homeGoBtn" title="Ir a inicio"><span class="material-symbols-outlined">home</span></button>
    <button id="homeSetBtn" title="Establecer como inicio \(desde input\)"><span class="material-symbols-outlined">push_pin</span></button>
    <button id="optionsBtn" title="Opciones"><span class="material-symbols-outlined">settings</span></button>  </div>  <div id="optionsPanel" style="display:none; background:rgba(0,0,0,0.4); padding:6px 10px; border-top:1px solid #333;">
    <label style="font-size:12px; opacity:.9;">Inicio:</label>
    <input id="homeInput" type="text" placeholder="URL o HSML inline" style="width:50%; max-width:520px;">
    <button id="homeSaveBtn" title="Guardar inicio">Guardar</button>
    <button id="optionsCloseBtn" title="Cerrar"><span class="material-symbols-outlined">close</span></button>  </div> <canvas id="canvas"></canvas>

  <div id="devPanel">
    <div id="devPanelHeader">
      <button id="inspectorTabBtn" class="devTabBtn" title="Inspector"><span class="material-symbols-outlined">explore</span></button>
      <button id="statusTabBtn" class="devTabBtn" title="Estado"><span class="material-symbols-outlined">bar_chart</span></button>
      <button id="toggleFreeCameraBtn" class="devTabBtn" title="Capturar/Liberar Mouse"><span class="material-symbols-outlined">mouse</span></button>
      <button id="toggleLightingBtn" class="devTabBtn" title="Luz"><span class="material-symbols-outlined">light_mode</span></button>
      <button id="toggleGridBtn" class="devTabBtn" title="Grid"><span class="material-symbols-outlined">grid_on</span></button>
      <button id="reloadBtn" class="devTabBtn" title="Recargar"><span class="material-symbols-outlined">refresh</span></button>
    </div>
    <div id="inspectorView"><strong>Árbol Virtual HSML</strong><div id="treeView"></div></div>
    <div id="statusView">
      <strong>Estado del Render</strong>
      <div style="margin-top:4px;">
        <div>FPS: <span id="fpsValue">0</span></div>
        <div>Memoria: <span id="ramValue">N/A</span></div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

    // ===================== Núcleo V3.1 (agnóstico, VR-ready) =====================
    class VirtualNode { 
      constructor(tag){ 
        this.tag=tag; 
        this.attributes={}; 
        this.children=[]; 
        this.key=VirtualNode.nextKey++;
      } 
      setAttribute(a,v){ this.attributes[a]=v; } 
      appendChild(c){ this.children.push(c); }
    }
    VirtualNode.nextKey = 1;

    let virtualDOM = null;
    const nodeKeyToObject = new Map();
    const vnodeToProxy = new WeakMap();

    // Índices
    const idToVNode = new Map();
    const classToVNodes = new Map();
    const keyToVNode = new Map();
    const vnodeEventHandlers = new WeakMap();

    // Loop de usuario
    const userUpdateFunctions = new Set();

    // Bus de eventos
    const eventHandlers = new Map();
    function on(event, handler){ if(!eventHandlers.has(event)) eventHandlers.set(event, new Set()); eventHandlers.get(event).add(handler); }
    function off(event, handler){ const s=eventHandlers.get(event); if(s) s.delete(handler); }
    function emit(event, data){
      const s=eventHandlers.get(event);
      if(s) s.forEach(fn=>{ try{ fn(data); }catch(e){ console.error('event handler error', e); } });
      try{
        const ce = new CustomEvent(event, { detail: data });
        document.dispatchEvent(ce);
      }catch(e){ /* CustomEvent not available? ignore */ }
    }

    function emitToNode(event, vnode, data){
      const proxy = createProxiedNode(vnode);
      const ev = { type:event, target: proxy, detail: data };
      const map = vnodeEventHandlers.get(vnode);
      if (map){ const set = map.get(event); if(set){ set.forEach(fn=>{ try{ fn(ev); }catch(e){ console.error('node handler error', e); } }); } }
      emit(event, { target: proxy, ...data });
    }

    function findVNodeFromObject(obj){ let o=obj; while(o){ const k=o.userData?.key; if(k && keyToVNode.has(k)) return keyToVNode.get(k); o=o.parent; } return null; }

    // Helpers
    const MATH = { clamp:(v,a,b)=>Math.max(a,Math.min(b,v)) };

    // Iluminación & helpers
    let lightingEnabled = true;
    const gridHelper = new THREE.GridHelper(120, 120, 0x444444, 0x222222); gridHelper.visible = false;
    const axesHelper = new THREE.AxesHelper(3); axesHelper.visible = false;

    // Stats
    let lastTimeStat = performance.now(), frames=0, currentFPS=0, lastFrameTS=performance.now();

    // DevTools scheduling
    let devtoolDirty=false, lastDevtoolUpdate=0; const DEVTOOL_THROTTLE_MS=100;
    function scheduleDevToolUpdate(){ devtoolDirty=true; }
    function maybeUpdateDevTool(){ if(!devtoolDirty) return; const now=performance.now(); if(now-lastDevtoolUpdate>=DEVTOOL_THROTTLE_MS){ reindexVirtualDOM(); updateDevTool(); devtoolDirty=false; lastDevtoolUpdate=now; } }

    function createProxiedNode(tagOrExisting){
      const realNode = (typeof tagOrExisting==='string') ? new VirtualNode(tagOrExisting) : tagOrExisting;
      if (vnodeToProxy.has(realNode)) return vnodeToProxy.get(realNode);
      keyToVNode.set(realNode.key, realNode);
      const proxy = new Proxy(realNode, {
        get(target, prop, receiver){
          if (prop === 'addEventListener') { return (event, handler)=>{ let m=vnodeEventHandlers.get(target); if(!m){ m=new Map(); vnodeEventHandlers.set(target,m);} if(!m.has(event)) m.set(event,new Set()); m.get(event).add(handler); }; }
          if (prop === 'removeEventListener') { return (event, handler)=>{ const m=vnodeEventHandlers.get(target); if(!m) return; const s=m.get(event); if(s) s.delete(handler); }; }
          if (prop === 'dispatchEvent') { return (event)=>{ const m=vnodeEventHandlers.get(target); if(!m) return; const s=m.get(event?.type||''); if(!s) return; s.forEach(fn=>{ try{ fn(event); }catch(e){ console.error('node handler error', e); } }); }; }
          if (prop === 'position') {
            return { get x(){return parseFloat(target.attributes.x ?? 0);}, set x(v){target.setAttribute('x', v); scheduleDevToolUpdate();}, get y(){return parseFloat(target.attributes.y ?? 0);}, set y(v){target.setAttribute('y', v); scheduleDevToolUpdate();}, get z(){return parseFloat(target.attributes.z ?? 0);}, set z(v){target.setAttribute('z', v); scheduleDevToolUpdate();} };
          }
          if (prop === 'rotation') {
            return { get x(){return parseFloat(target.attributes.rx ?? 0);}, set x(v){target.setAttribute('rx', v); scheduleDevToolUpdate();}, get y(){return parseFloat(target.attributes.ry ?? 0);}, set y(v){target.setAttribute('ry', v); scheduleDevToolUpdate();}, get z(){return parseFloat(target.attributes.rz ?? 0);}, set z(v){target.setAttribute('rz', v); scheduleDevToolUpdate();} };
          }
          if (prop === 'appendChild') { return (childProxy)=>{ target.children.push(childProxy); }; }
          if (prop === 'setAttribute') { return (attr,val)=>{ target.setAttribute(attr,val); scheduleDevToolUpdate(); }; }
          if (prop in target.attributes) return target.attributes[prop];
          return Reflect.get(target, prop, receiver);
        },
        set(target, prop, value){
          if ([ 'src','class','id','scale','x','y','z','rx','ry','rz','color','texture','metalness','roughness','emissive','collider','visible','width','height','depth','radius','thickness','text','html','font','fontSize','maxwidth','lineheight','bg','autoplay','loop','muted','unitsperpx' ].includes(prop)) { target.setAttribute(prop, value); scheduleDevToolUpdate(); return true; }
          return Reflect.set(target, prop, value);
        }
      });
      vnodeToProxy.set(realNode, proxy); return proxy;
    }

    // ----------------- Parser HSML -----------------
    function parseHSML(xmlNode){ if(!xmlNode||xmlNode.nodeType!==Node.ELEMENT_NODE) return null; const vnode=new VirtualNode(xmlNode.nodeName); for(let i=0;i<xmlNode.attributes.length;i++){ const a=xmlNode.attributes[i]; vnode.setAttribute(a.name, a.value); } Array.from(xmlNode.childNodes).forEach(ch=>{ const c=parseHSML(ch); if(c) vnode.appendChild(c); }); return vnode; }
    function reindexVirtualDOM(){ idToVNode.clear(); classToVNodes.clear(); keyToVNode.clear(); (function walk(v){ if(!v) return; keyToVNode.set(v.key, v); const id=v.attributes.id; if(id) idToVNode.set(id,v); const cls=(v.attributes.class||'').trim(); if(cls){ cls.split(/\s+/).forEach(c=>{ if(!classToVNodes.has(c)) classToVNodes.set(c,new Set()); classToVNodes.get(c).add(v); }); } (v.children||[]).forEach(walk); })(virtualDOM); }

    // ----------------- HSML root helpers (hsml/head/space) -----------------
    const globalState = {};
    function extractHeadData(headEl){
      const meta = { position:null, scale:null, rotation:null, spawn:null };
      const extraChildren = [];
      if(!headEl) return { meta, extraChildren };
      const metas = headEl.getElementsByTagName('meta');
      for(let i=0;i<metas.length;i++){
        const m = metas[i];
        const t = (m.getAttribute('type')||'').toLowerCase();
        const x=parseFloat(m.getAttribute('x')||0), y=parseFloat(m.getAttribute('y')||0), z=parseFloat(m.getAttribute('z')||0);
        if(t==='position') meta.position = {x,y,z};
        else if(t==='scale') meta.scale = {x,y,z};
        else if(t==='rotation') meta.rotation = {x,y,z};
        else if(t==='spawn'){
          const yaw = parseFloat(m.getAttribute('yaw'));
          const pitch = parseFloat(m.getAttribute('pitch'));
          meta.spawn = { x: m.hasAttribute('x')?x:undefined, y: m.hasAttribute('y')?y:undefined, z: m.hasAttribute('z')?z:undefined, yaw: isNaN(yaw)?undefined:yaw, pitch: isNaN(pitch)?undefined:pitch };
        }
      }
      const states = headEl.getElementsByTagName('state');
      for(let i=0;i<states.length;i++){
        const s = states[i];
        const name = s.getAttribute('name')||'default';
        const def = s.getAttribute('default');
        globalState[name] = def;
      }
      const lights = headEl.getElementsByTagName('light');
      for(let i=0;i<lights.length;i++){
        const vnode = parseHSML(lights[i]);
        if(vnode) extraChildren.push(vnode);
      }
      return { meta, extraChildren };
    }

    function parseHSMLRootFromString(hsml){
      const parser=new DOMParser(); const xml=parser.parseFromString(hsml, 'text/xml');
      let hsmlEl = xml.getElementsByTagName('hsml')[0];
      if(hsmlEl){
        const head = hsmlEl.getElementsByTagName('head')[0]||null;
        const spaceXML = hsmlEl.getElementsByTagName('space')[0];
        if(!spaceXML) return { vnode:null };
        const { meta, extraChildren } = extractHeadData(head);
        const vnode = parseHSML(spaceXML);
        if(meta.position){ vnode.setAttribute('x', meta.position.x); vnode.setAttribute('y', meta.position.y); vnode.setAttribute('z', meta.position.z); }
        if(meta.scale && meta.scale.x===meta.scale.y && meta.scale.y===meta.scale.z){ vnode.setAttribute('scale', meta.scale.x); }
        if(meta.rotation){ vnode.setAttribute('rx', meta.rotation.x); vnode.setAttribute('ry', meta.rotation.y); vnode.setAttribute('rz', meta.rotation.z); }
        vnode.children = [...extraChildren, ...vnode.children];
        return { vnode, meta };
      } else {
        const spaceXML = xml.getElementsByTagName('space')[0];
        if(!spaceXML) return { vnode:null };
        return { vnode: parseHSML(spaceXML), meta: { position:null, scale:null, rotation:null, spawn:null } };
      }
    }

    // ----------------- Construcción de escena (tags genéricos) -----------------
    const mixers = new Set();

    function getDefaultMaterial(attrs){
      const color = attrs.color ? new THREE.Color(attrs.color) : new THREE.Color('#cccccc');
      const mat = lightingEnabled ? new THREE.MeshStandardMaterial({ color, metalness: parseFloat(attrs.metalness ?? 0), roughness: parseFloat(attrs.roughness ?? 1), emissive: new THREE.Color(attrs.emissive||'#000000') }) : new THREE.MeshBasicMaterial({ color });
      if (attrs.texture) new THREE.TextureLoader().load(attrs.texture, tex => { tex.colorSpace = THREE.SRGBColorSpace; tex.wrapS=tex.wrapT=THREE.RepeatWrapping; mat.map = tex; mat.needsUpdate = true; });
      return mat;
    }

    // ----------------- Text/HTML helpers -----------------
    function drawWrappedTextCanvas(text, opts={}){
      const fontSize = parseInt(opts.fontSize ?? 48);
      const fontFamily = String(opts.fontFamily ?? 'sans-serif');
      const color = String(opts.color ?? '#ffffff');
      const bg = opts.bg ?? null; // null/transparent or color
      const padding = parseInt(opts.padding ?? 16);
      const lineHeight = parseFloat(opts.lineHeight ?? 1.2);
      const maxWidth = parseInt(opts.maxWidth ?? 1024);
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = `${fontSize}px ${fontFamily}`;
      const words = String(text||'').split(/\s+/);
      const lines = [];
      let line = '';
      const testWidth = (s)=> ctx.measureText(s).width;
      for(let i=0;i<words.length;i++){
        const test = line ? (line+' '+words[i]) : words[i];
        if (testWidth(test) <= maxWidth) line = test; else { if(line) lines.push(line); line = words[i]; }
      }
      if (line) lines.push(line);
      const textWidth = Math.min(maxWidth, Math.max(...lines.map(s=>testWidth(s)), 1));
      const textHeight = Math.max(1, Math.ceil(lines.length * fontSize * lineHeight));
      canvas.width = Math.ceil(textWidth + padding*2);
      canvas.height = Math.ceil(textHeight + padding*2);
      const ratio = window.devicePixelRatio || 1;
      canvas.width *= ratio; canvas.height *= ratio;
      canvas.style.width = (canvas.width/ratio)+'px';
      canvas.style.height = (canvas.height/ratio)+'px';
      ctx.scale(ratio, ratio);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if (bg){ ctx.fillStyle = bg; ctx.fillRect(0,0,canvas.width/ratio,canvas.height/ratio); }
      ctx.fillStyle = color;
      ctx.font = `${fontSize}px ${fontFamily}`;
      ctx.textBaseline = 'top';
      const x = padding, startY = padding; let y = startY;
      for(const ln of lines){ ctx.fillText(ln, x, y); y += fontSize*lineHeight; }
      return { canvas, widthPx: canvas.width/ratio, heightPx: canvas.height/ratio };
    }

    function createTextPlane(attrs, kind='text'){
      const opts = {
        fontSize: parseInt(attrs.fontsize ?? attrs.fontSize ?? 48),
        fontFamily: attrs.font || 'sans-serif',
        color: attrs.color || '#ffffff',
        bg: attrs.bg || null,
        maxWidth: parseInt(attrs.maxwidth ?? attrs.maxWidth ?? 1024),
        lineHeight: parseFloat(attrs.lineheight ?? 1.2),
      };
      const contentRaw = kind==='html' ? (attrs.html || attrs.text || '') : (attrs.text || '');
      const content = kind==='html' ? String(contentRaw).replace(/<br\s*\/?\s*>/gi, '\n').replace(/<[^>]+>/g,'') : String(contentRaw);
      const drawn = drawWrappedTextCanvas(content, opts);
      const texture = new THREE.CanvasTexture(drawn.canvas); texture.colorSpace = THREE.SRGBColorSpace;
      const material = new THREE.MeshBasicMaterial({ map:texture, transparent:true });
      const unitsPerPx = parseFloat(attrs.unitsperpx ?? 0.002);
      const w = parseFloat(attrs.width ?? (drawn.widthPx*unitsPerPx));
      const h = parseFloat(attrs.height ?? (drawn.heightPx*unitsPerPx));
      const geo = new THREE.PlaneGeometry(Math.max(1e-3,w), Math.max(1e-3,h));
      const mesh = new THREE.Mesh(geo, material);
      mesh.userData.kind = kind;
      mesh.userData._content = content;
      mesh.userData._opts = opts;
      mesh.userData._unitsPerPx = unitsPerPx;
      mesh.userData.updateContent = (newAttrs)=>{
        const nextRaw = kind==='html' ? (newAttrs.html || newAttrs.text || '') : (newAttrs.text || '');
        const next = kind==='html' ? String(nextRaw).replace(/<br\s*\/?\s*>/gi, '\n').replace(/<[^>]+>/g,'') : String(nextRaw);
        const o = {
          fontSize: parseInt(newAttrs.fontsize ?? newAttrs.fontSize ?? mesh.userData._opts.fontSize),
          fontFamily: newAttrs.font || mesh.userData._opts.fontFamily,
          color: newAttrs.color || mesh.userData._opts.color,
          bg: newAttrs.bg ?? mesh.userData._opts.bg,
          maxWidth: parseInt(newAttrs.maxwidth ?? newAttrs.maxWidth ?? mesh.userData._opts.maxWidth),
          lineHeight: parseFloat(newAttrs.lineheight ?? mesh.userData._opts.lineHeight),
        };
        const d = drawWrappedTextCanvas(next, o);
        mesh.material.map.dispose();
        mesh.material.map = new THREE.CanvasTexture(d.canvas); mesh.material.map.colorSpace = THREE.SRGBColorSpace; mesh.material.needsUpdate = true;
        const unitsPerPx = parseFloat(newAttrs.unitsperpx ?? mesh.userData._unitsPerPx);
        const w = parseFloat(newAttrs.width ?? (d.widthPx*unitsPerPx));
        const h = parseFloat(newAttrs.height ?? (d.heightPx*unitsPerPx));
        mesh.geometry.dispose(); mesh.geometry = new THREE.PlaneGeometry(Math.max(1e-3,w), Math.max(1e-3,h));
        mesh.userData._content = next; mesh.userData._opts = o; mesh.userData._unitsPerPx = unitsPerPx;
      };
      return mesh;
    }

    // ----------------- Video helper -----------------
    function createVideoPlane(attrs){
      const wAttr = parseFloat(attrs.width ?? 1.6);
      const hAttr = parseFloat(attrs.height ?? 0.9);
      const geo = new THREE.PlaneGeometry(wAttr, hAttr);
      const video = document.createElement('video');
      if (attrs.src) video.src = attrs.src;
      video.autoplay = String(attrs.autoplay ?? 'true').toLowerCase()!=='false';
      video.loop = String(attrs.loop ?? 'true').toLowerCase()!=='false';
      video.muted = String(attrs.muted ?? 'true').toLowerCase()!=='false';
      video.playsInline = true;
      const tex = new THREE.VideoTexture(video); tex.colorSpace = THREE.SRGBColorSpace; tex.needsUpdate = true;
      const mat = new THREE.MeshBasicMaterial({ map: tex });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.userData.kind = 'video';
      mesh.userData._video = video;
      mesh.userData.updateFromAttrs = (newAttrs)=>{
        const v = mesh.userData._video;
        if(newAttrs.src && newAttrs.src!==v.src){ v.src = newAttrs.src; if(v.autoplay) v.play().catch(()=>{}); }
        v.autoplay = String(newAttrs.autoplay ?? v.autoplay).toLowerCase()!=='false';
        v.loop = String(newAttrs.loop ?? v.loop).toLowerCase()!=='false';
        v.muted = String(newAttrs.muted ?? v.muted).toLowerCase()!=='false';
      };
      video.addEventListener('loadedmetadata', ()=>{
        const aspect = (video.videoWidth||16)/(video.videoHeight||9);
        let w = parseFloat(attrs.width ?? (1.6));
        let h = parseFloat(attrs.height ?? (w/aspect));
        mesh.geometry.dispose(); mesh.geometry = new THREE.PlaneGeometry(w, h);
      });
      if (video.autoplay) video.play().catch(()=>{});
      return mesh;
    }
    const gltfCache = new Map();
    async function getGLTFScene(src){ if(gltfCache.has(src)) return gltfCache.get(src).clone(true); const loader=new GLTFLoader(); return new Promise((resolve,reject)=>{ loader.load(src, (gltf)=>{ gltfCache.set(src,gltf.scene); resolve(gltf.scene.clone(true)); const mixer=new THREE.AnimationMixer(gltf.scene); mixers.add(mixer); if(gltf.animations && gltf.animations.length){ const clip = gltf.animations[0]; mixer.clipAction(clip).play(); } }, undefined, reject); }); }

    function clearColliders(){ staticColliders.length=0; }

    function isColliderEnabled(attrs){
      if (attrs.collider === undefined) return false;
      const val = String(attrs.collider).toLowerCase().trim();
      if (val === '' || val === 'true' || val === '1' || val === 'yes' || val === 'on') return true;
      if (val === 'box') return true;
      return false;
    }

    function registerColliderFromAttrs(vnode, obj){
      const a = vnode.attributes || {};
      if (!isColliderEnabled(a)) return;
      const tag = vnode.tag.toLowerCase();
      if (!['box','plane','sphere'].includes(tag)) return;

      let computeHalf;
      if (tag==='box'){
        computeHalf = ()=>{
          const sx=obj.scale.x, sy=obj.scale.y, sz=obj.scale.z;
          const w=parseFloat(a.width||1)*sx, h=parseFloat(a.height||1)*sy, d=parseFloat(a.depth||1)*sz;
          return new THREE.Vector3(w/2, h/2, d/2);
        };
      } else if (tag==='plane'){
        computeHalf = ()=>{
          const sx=obj.scale.x, sy=obj.scale.y, sz=obj.scale.z;
          const w=parseFloat(a.width||5)*sx, d=parseFloat(a.height||5)*sz;
          const thick=parseFloat(a.thickness ?? 0.1)*sy;
          return new THREE.Vector3(w/2, thick/2, d/2);
        };
      } else if (tag==='sphere'){
        computeHalf = ()=>{
          const s=obj.scale.x; const r=parseFloat(a.radius||0.5)*s;
          return new THREE.Vector3(r, r, r);
        };
      }

      const handle = {
        object: obj,
        vnode,
        min: new THREE.Vector3(),
        max: new THREE.Vector3(),
        half: new THREE.Vector3(),
        recalcHalf(){ this.half.copy(computeHalf()); },
        __id: Math.random().toString(36).slice(2)
      };
      handle.recalcHalf();
      const center = obj.getWorldPosition(new THREE.Vector3());
      handle.min.set(center.x - handle.half.x, center.y - handle.half.y, center.z - handle.half.z);
      handle.max.set(center.x + handle.half.x, center.y + handle.half.y, center.z + handle.half.z);
      staticColliders.push(handle);
      return handle;
    }

    async function buildSceneFromVirtual(vnode, parentObj){
      let obj; const tag=vnode.tag; const a=vnode.attributes||{};
      const classList=(a.class||'').split(/\s+/).filter(Boolean);

      if (tag==='group' || tag==='space') { obj=new THREE.Object3D(); }
      else if (tag==='include') {
        obj = new THREE.Object3D();
        obj.userData.kind = 'include';
        obj.userData.includeKeys = new Set();
        const includeUrl = a.src;
        if (includeUrl) {
          try {
            const res = await fetch(includeUrl);
            const text = await res.text();
            const parsed = parseHSMLRootFromString(text);
            const incRoot = parsed.vnode;
            if (incRoot) {
              (incRoot.children || []).forEach(ch => { vnode.appendChild(ch); obj.userData.includeKeys.add(ch.key); });
              obj.userData.includeSrc = includeUrl;
              obj.userData.includeBase = includeUrl;
              // Asegurar que los IDs del include estén indexados antes de correr scripts
              reindexVirtualDOM();
              scheduleDevToolUpdate();
              // Ejecutar scripts del HSML incluido (inline, src o code="...")
              try {
                const xml = new DOMParser().parseFromString(text, 'text/xml');
                let scriptNodes = [];
                const hsmlEl = xml.getElementsByTagName('hsml')[0] || null;
                if (hsmlEl) {
                  scriptNodes = Array.from(hsmlEl.getElementsByTagName('script'));
                } else {
                  const spaceEl = xml.getElementsByTagName('space')[0] || null;
                  if (spaceEl) scriptNodes = Array.from(spaceEl.getElementsByTagName('script'));
                }
                // Mapear data-* del <include> a un overlay temporal de state
                const includeState = {};
                for (const k in a) {
                  if (k && k.startsWith('data-')) {
                    const key = k.slice(5);
                    includeState[key] = a[k];
                  }
                }
                if (scriptNodes.length) {
                  for (const node of scriptNodes) {
                    const ssrc = node.getAttribute('src');
                    const codeAttr = node.getAttribute('code');
                    const inline = (node.textContent || '').trim();
                    if (ssrc) {
                      const abs = new URL(ssrc, includeUrl).toString();
                      fetch(abs)
                        .then(r => r.text())
                        .then(code => runSandboxWithState(code, includeState))
                        .catch(err => console.error('Script load error', abs, err));
                    } else if (codeAttr && codeAttr.trim()) {
                      runSandboxWithState(codeAttr, includeState);
                    } else if (inline) {
                      runSandboxWithState(inline, includeState);
                    }
                  }
                }
              } catch (e) {
                console.error('Include script error', includeUrl, e);
              }
              // Reindexar nuevamente tras posibles mutaciones de scripts
              reindexVirtualDOM();
              scheduleDevToolUpdate();
            }
          } catch (e) {
            console.error('Include load error', includeUrl, e);
          }
        }
      }
      else if (tag==='model') { obj=new THREE.Object3D(); const src=a.src; if(src){ getGLTFScene(src).then(sceneChild=>{ while(obj.children.length>0) obj.remove(obj.children[0]); obj.add(sceneChild); }).catch(err=>console.error('GLTF load error',src,err)); } }
      else if (tag==='box') { const w=parseFloat(a.width??1), h=parseFloat(a.height??1), d=parseFloat(a.depth??1); const geo=new THREE.BoxGeometry(w,h,d); obj=new THREE.Mesh(geo, getDefaultMaterial(a)); }
      else if (tag==='sphere'){ const r=parseFloat(a.radius??0.5), ws=parseInt(a.widthSegments??16), hs=parseInt(a.heightSegments??12); const geo=new THREE.SphereGeometry(r,ws,hs); obj=new THREE.Mesh(geo, getDefaultMaterial(a)); }
      else if (tag==='plane'){ const w=parseFloat(a.width??5), h=parseFloat(a.height??5); const geo=new THREE.PlaneGeometry(w,h); const mesh=new THREE.Mesh(geo, getDefaultMaterial(a)); mesh.rotation.x=-Math.PI/2; obj=mesh; }
      else if (tag==='text'){ obj=createTextPlane(a, 'text'); }
      else if (tag==='html'){ obj=createTextPlane(a, 'html'); }
      else if (tag==='video'){ obj=createVideoPlane(a); }
      else if (tag==='light'){ const type=(a.type||'ambient').toLowerCase(); const color=new THREE.Color(a.color||'#ffffff'); const intensity=parseFloat(a.intensity??1); if (type==='ambient') obj=new THREE.AmbientLight(color,intensity); else if(type==='directional'){ obj=new THREE.DirectionalLight(color,intensity); obj.position.set(5,10,5); } else if(type==='point'){ obj=new THREE.PointLight(color,intensity, parseFloat(a.distance??0)); } else if(type==='hemisphere'){ obj=new THREE.HemisphereLight(0xffffff,0x444444,intensity); } else { obj=new THREE.Object3D(); } }
      else if (tag==='audio'){
        obj=new THREE.Object3D();
        obj.userData.kind='audio';
        obj.userData.audio=null;
        obj.userData._audioState={ src:null, loop:false, autoplay:false, volume:0.7, positional:false, refDistance:8 };
        function attachAudioFromAttrs(attrs){
          const wantPos = String(attrs.positional).toLowerCase()==='true';
          const vol = isNaN(parseFloat(attrs.volume))? 0.7 : parseFloat(attrs.volume);
          const loop = String(attrs.loop).toLowerCase()==='true';
          const auto = String(attrs.autoplay).toLowerCase()==='true';
          const refD = isNaN(parseFloat(attrs.refDistance))? 8 : parseFloat(attrs.refDistance);
          const src = attrs.src||null;
          const st = obj.userData._audioState;
          const needsRebuild = (st.positional!==wantPos) || (st.src!==src);
          st.positional = wantPos; st.loop=loop; st.autoplay=auto; st.volume=vol; st.refDistance=refD; st.src=src;
          if (!src) { if(obj.userData.audio){ try{ obj.userData.audio.stop(); }catch(_){}; obj.remove(obj.userData.audio); obj.userData.audio=null; } return; }
          if (needsRebuild){
            if (obj.userData.audio){ try{ obj.userData.audio.stop(); }catch(_){}; obj.remove(obj.userData.audio); obj.userData.audio=null; }
            const a = wantPos ? new THREE.PositionalAudio(audioListener) : new THREE.Audio(audioListener);
            obj.add(a);
            obj.userData.audio = a;
            audioLoader.load(src, buffer=>{
              a.setBuffer(buffer);
              a.setLoop(loop);
              a.setVolume(vol);
              if (wantPos && a.setRefDistance) a.setRefDistance(refD);
              if (auto) a.play();
            });
          } else {
            const a = obj.userData.audio;
            if (a){
              a.setLoop(loop);
              a.setVolume(vol);
              if (wantPos && a.setRefDistance) a.setRefDistance(refD);
              // autoplay handled on (re)load; manual play if requested and buffer present
              if (auto && a.buffer && !a.isPlaying) a.play();
            }
          }
        }
        obj.userData.updateFromAttrs = attachAudioFromAttrs;
        attachAudioFromAttrs(a);
      }
      else { obj=new THREE.Object3D(); }

      if (String(a.visible).toLowerCase()==='false') obj.visible = false;

      obj.userData.key = vnode.key; parentObj.add(obj); nodeKeyToObject.set(vnode.key, obj);

      for(const child of vnode.children){ await buildSceneFromVirtual(child, obj); }

      const behaviors = new Set(classList);
      if (behaviors.has('spin')) userUpdateFunctions.add((dt)=>{ vnode.attributes.ry = (parseFloat(vnode.attributes.ry||0)+dt)% (Math.PI*2); });
      if (behaviors.has('pulse')) { let t=0; const amp=parseFloat(a.amp||0.6), speed=parseFloat(a.speed||1.5), y0=parseFloat(a.y||0); userUpdateFunctions.add(dt=>{ t+=dt*speed; vnode.attributes.y = (y0 + Math.sin(t)*amp).toFixed(5); }); }

      registerColliderFromAttrs(vnode, obj);
    }

    // Actualiza en vivo un <include> cuando cambia su atributo src
    async function updateIncludeFor(vnode, obj, newSrc){
      try {
        // limpiar contenido previo del include (virtual DOM y escena)
        const keys = obj.userData?.includeKeys || new Set();
        if (keys.size) {
          for (const k of keys) {
            removeNodeByKey(virtualDOM, k);
            const o = nodeKeyToObject.get(k);
            if (o && o.parent) o.parent.remove(o);
            nodeKeyToObject.delete(k);
          }
          obj.userData.includeKeys = new Set();
        }
        // remover objetos hijos directos 3D
        obj.children.slice().forEach(c => obj.remove(c));

        if (!newSrc) {
          obj.userData.includeSrc = undefined;
          scheduleDevToolUpdate();
          reindexVirtualDOM();
          return;
        }

        // resolver URL absoluta contra base conocida
        let abs = newSrc;
        try {
          if (!/^https?:\/\//i.test(newSrc)) {
            const base = obj.userData?.includeBase || (lastHSMLSource && lastHSMLSource.type==='url' ? lastHSMLSource.value : location.href);
            abs = new URL(newSrc, base).toString();
          }
        } catch(_) { /* keep as-is */ }

        const res = await fetch(abs);
        const text = await res.text();
        const parsed = parseHSMLRootFromString(text);
        const incRoot = parsed.vnode;
        if (incRoot) {
          (incRoot.children || []).forEach(ch => { vnode.children.push(ch); (obj.userData.includeKeys||=new Set()).add(ch.key); });
          for (const ch of incRoot.children) { await buildSceneFromVirtual(ch, obj); }
          obj.userData.includeSrc = newSrc;
          obj.userData.includeBase = abs;

          // indexar y ejecutar scripts del include
          reindexVirtualDOM();
          scheduleDevToolUpdate();
          try {
            const xml = new DOMParser().parseFromString(text, 'text/xml');
            let scriptNodes = [];
            const hsmlEl = xml.getElementsByTagName('hsml')[0] || null;
            if (hsmlEl) scriptNodes = Array.from(hsmlEl.getElementsByTagName('script'));
            else { const spaceEl = xml.getElementsByTagName('space')[0] || null; if (spaceEl) scriptNodes = Array.from(spaceEl.getElementsByTagName('script')); }
            if (scriptNodes.length) {
              // Overlay de state desde data-* del <include>
              const includeState = {};
              const attrs = vnode.attributes||{};
              for (const k in attrs){ if (k && k.startsWith('data-')){ includeState[k.slice(5)] = attrs[k]; } }
              for (const node of scriptNodes) {
                const ssrc = node.getAttribute('src');
                const codeAttr = node.getAttribute('code');
                const inline = (node.textContent || '').trim();
                if (ssrc) {
                  const absScript = new URL(ssrc, abs).toString();
                  fetch(absScript).then(r=>r.text()).then(code=>runSandboxWithState(code, includeState)).catch(err=>console.error('Script load error', absScript, err));
                } else if (codeAttr && codeAttr.trim()) { runSandboxWithState(codeAttr, includeState); }
                else if (inline) { runSandboxWithState(inline, includeState); }
              }
            }
          } catch(e){ console.error('Include script error', abs, e); }
          reindexVirtualDOM();
          scheduleDevToolUpdate();
        } else {
          obj.userData.includeSrc = newSrc;
          obj.userData.includeBase = abs;
        }
      } catch(e){ console.error('updateIncludeFor error', e); }
    }

    function applyTransformsRecursively(vnode){
      const obj=nodeKeyToObject.get(vnode.key); if(obj){ const attrs=vnode.attributes||{};
        // Soporte de recarga dinámica para <include src="...">
        if (vnode.tag === 'include') {
          const desired = attrs.src !== undefined && attrs.src !== null && String(attrs.src).trim() !== '' ? String(attrs.src) : undefined;
          const current = obj.userData ? obj.userData.includeSrc : undefined;
          if (desired !== current && !obj.userData.includeLoading) {
            obj.userData.includeLoading = true;
            (async ()=>{ try { await updateIncludeFor(vnode, obj, desired); } finally { obj.userData.includeLoading = false; } })();
          }
        }
        if (attrs.scale!==undefined){ const s=parseFloat(attrs.scale); if(!isNaN(s)) obj.scale.set(s,s,s); }
        if (attrs.x!==undefined) obj.position.x = parseFloat(attrs.x)||0;
        if (attrs.y!==undefined) obj.position.y = parseFloat(attrs.y)||0;
        if (attrs.z!==undefined) obj.position.z = parseFloat(attrs.z)||0;
        if (attrs.rx!==undefined) obj.rotation.x = parseFloat(attrs.rx)||0;
        if (attrs.ry!==undefined) obj.rotation.y = parseFloat(attrs.ry)||0;
        if (attrs.rz!==undefined) obj.rotation.z = parseFloat(attrs.rz)||0;
        if (obj.userData && (obj.userData.kind==='text' || obj.userData.kind==='html') && typeof obj.userData.updateContent==='function'){
          obj.userData.updateContent(attrs);
        }
        if (obj.userData && obj.userData.kind==='video' && typeof obj.userData.updateFromAttrs==='function'){
          obj.userData.updateFromAttrs(attrs);
        }
        if (obj.userData && obj.userData.kind==='audio' && typeof obj.userData.updateFromAttrs==='function'){
          obj.userData.updateFromAttrs(attrs);
        }
        if (attrs.color!==undefined){
          const col = new THREE.Color(attrs.color);
          if (obj.isLight && obj.color){ obj.color.copy(col); }
          else if (obj.isMesh && obj.material && obj.material.color){ obj.material.color.copy(col); obj.material.needsUpdate=true; }
          else { obj.traverse(n=>{ if(n.isMesh && n.material && n.material.color){ n.material.color.copy(col); n.material.needsUpdate=true; } if(n.isLight && n.color){ n.color.copy(col); } }); }
        }
      }
      vnode.children.forEach(ch=>applyTransformsRecursively(ch));
    }

    // ----------------- DevTools -----------------
    function updateDevTool(){ const treeView=document.getElementById('treeView'); treeView.innerHTML=''; if(!virtualDOM) return; const domTree=buildVirtualTreeHTML(virtualDOM); if(domTree) treeView.appendChild(domTree); }
    function buildVirtualTreeHTML(vnode){ const li=document.createElement('li'); const header=document.createElement('div'); header.style.display='flex'; header.style.flexWrap='wrap'; header.style.alignItems='center'; const tagSpan=document.createElement('span'); tagSpan.textContent=`<${vnode.tag}>`; header.appendChild(tagSpan); for(const an in vnode.attributes){ const av=vnode.attributes[an]; const label=document.createElement('span'); label.classList.add('attrLabel'); label.textContent=` ${an}="`; const inp=document.createElement('span'); inp.classList.add('attrInput'); inp.contentEditable=true; inp.textContent=av; inp.addEventListener('blur',()=>{ vnode.attributes[an]=inp.textContent.trim(); scheduleDevToolUpdate(); }); label.appendChild(inp); const q=document.createElement('span'); q.textContent='"'; label.appendChild(q); header.appendChild(label); } const centerBtn=document.createElement('button'); centerBtn.textContent='Centrar'; centerBtn.classList.add('actionBtn'); centerBtn.addEventListener('click',e=>{ e.stopPropagation(); scene.traverse(obj=>{ if(obj.userData && obj.userData.key===vnode.key) centerCameraOnObject(obj); }); }); header.appendChild(centerBtn); const removeBtn=document.createElement('button'); removeBtn.textContent='Eliminar'; removeBtn.classList.add('actionBtn'); removeBtn.addEventListener('click',e=>{ e.stopPropagation(); removeNodeByKey(virtualDOM, vnode.key); const obj=nodeKeyToObject.get(vnode.key); if(obj&&obj.parent) obj.parent.remove(obj); nodeKeyToObject.delete(vnode.key); scheduleDevToolUpdate(); }); header.appendChild(removeBtn); li.appendChild(header); if(vnode.children.length>0){ const ul=document.createElement('ul'); vnode.children.forEach(ch=>{ const c=buildVirtualTreeHTML(ch); if(c) ul.appendChild(c); }); li.appendChild(ul); } return li; }
    function removeNodeByKey(rootVNode,key){ if(!rootVNode||!rootVNode.children) return false; for(let i=0;i<rootVNode.children.length;i++){ if(rootVNode.children[i].key===key){ rootVNode.children.splice(i,1); return true; } else { if(removeNodeByKey(rootVNode.children[i],key)) return true; } } return false; }
    function centerCameraOnObject(obj){ const pos=new THREE.Vector3(); obj.getWorldPosition(pos); player.position.set(pos.x, player.position.y, pos.z+5); yaw = Math.atan2((player.position.x - pos.x), (player.position.z - pos.z)); if(!input.isXR){ camera.quaternion.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ')); } xrRig.position.set(player.position.x, player.position.y - player.eyeHeight, player.position.z); }

    // ----------------- Render/Scene Setup -----------------
    const canvas=document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
    renderer.setPixelRatio(window.devicePixelRatio); renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled=true; renderer.xr.setReferenceSpaceType('local-floor');
    const vrButton=VRButton.createButton(renderer); document.getElementById('toolbar').appendChild(vrButton);

    const scene = new THREE.Scene(); scene.background = new THREE.Color(0x202020);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 2000);

    // RIG del usuario
    const xrRig = new THREE.Group();
    scene.add(xrRig);
    xrRig.add(camera);

    window.addEventListener('resize', ()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.65);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.2); dirLight.position.set(4,10,6);
    scene.add(ambientLight); scene.add(dirLight); scene.add(gridHelper); scene.add(axesHelper);

    // ----------------- Audio helpers -----------------
    const audioListener = new THREE.AudioListener();
    camera.add(audioListener);
    const audioLoader = new THREE.AudioLoader();
    function playSoundOneShot(url, volume=0.7){ const s = new THREE.Audio(audioListener); audioLoader.load(url, buffer=>{ s.setBuffer(buffer); s.setVolume(volume); s.play(); }); return s; }
    function attachPositionalAudio(obj, url, { loop=false, volume=0.6, refDistance=8 }={}){ const a = new THREE.PositionalAudio(audioListener); audioLoader.load(url, buffer=>{ a.setBuffer(buffer); a.setLoop(loop); a.setVolume(volume); a.setRefDistance(refDistance); a.play(); }); obj.add(a); return a; }

    // ----------------- Controlador de personaje (abstraído) -----------------
    const input = { keys:{}, pointerLocked:false, isXR:false };

    class PlayerBase {
      constructor(env, opts={}){
        this.env = env;
        this.position   = opts.position   || new THREE.Vector3(0,1.7,6);
        this.radius     = opts.radius     ?? 0.4;
        this.eyeHeight  = opts.eyeHeight  ?? 1.7;
        this.speed      = opts.speed      ?? 3.5;
        this.sprintMult = opts.sprintMult ?? 1.6;
        this.gravity    = opts.gravity    ?? 18.0;
        this.jumpSpeed  = opts.jumpSpeed  ?? 6.0;
        this.velY = 0; this.grounded=false;
      }
      applyVerticalPhysics(dt, desiredX, desiredZ){
        const { getGroundHeightAt, getCeilingHeightAt } = this.env.helpers;
        const groundY = getGroundHeightAt(desiredX, desiredZ);
        this.velY -= this.gravity * dt;
        let nextY = this.position.y + this.velY * dt;
        if (nextY - this.eyeHeight <= groundY){
          nextY = groundY + this.eyeHeight; this.velY = 0; this.grounded = true;
        } else {
          this.grounded = false;
        }
        const ceil = getCeilingHeightAt(desiredX, desiredZ);
        if (ceil < Infinity && nextY >= ceil - 1e-3){
          nextY = Math.min(nextY, ceil - 1e-3);
          if (this.velY>0) this.velY = 0;
        }
        return nextY;
      }
      syncRig(){
        const { xrRig, camera, input, renderer, THREE } = this.env;
        if(input.isXR){
          const camXR = renderer.xr.getCamera(camera);
          const headWorld = new THREE.Vector3().setFromMatrixPosition(camXR.matrixWorld);
          const headLocal = headWorld.clone();
          xrRig.worldToLocal(headLocal);
          xrRig.position.set(
            this.position.x - headLocal.x,
            this.position.y - headLocal.y,
            this.position.z - headLocal.z
          );
        } else {
          xrRig.position.set(this.position.x, this.position.y - this.eyeHeight, this.position.z);
          camera.position.set(0, this.eyeHeight, 0);
        }
      }
      update(_dt){ /* abstract */ }
    }

    // Nota: mantenemos yaw/pitch globales para no romper la API de camera existente
    let yaw=0, pitch=0; const mouseSensitivity=0.0022;

    class DesktopPlayer extends PlayerBase {
      update(dt){
        const { THREE, camera, xrRig, input, helpers } = this.env;
        const forward = new THREE.Vector3(0,0,-1).applyEuler(new THREE.Euler(0,yaw,0,'YXZ'));
        const right   = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();
        let move = new THREE.Vector3();
        const base = this.speed * ( (input.keys['ShiftLeft']||input.keys['ShiftRight']) ? this.sprintMult : 1 );
        if(input.keys['KeyW']) move.add(forward);
        if(input.keys['KeyS']) move.addScaledVector(forward,-1);
        if(input.keys['KeyA']) move.addScaledVector(right,-1);
        if(input.keys['KeyD']) move.add(right);
        if (move.lengthSq()>1e-6) move.normalize().multiplyScalar(base*dt);

        // Subdivide movement to avoid tunneling through thin walls
        let desired = this.position.clone();
        if (move.lengthSq()>0){
          const steps = Math.max(1, Math.ceil(move.length() / (this.radius*0.5)));
          const stepVec = move.clone().multiplyScalar(1/steps);
          for(let i=0;i<steps;i++){
            desired.add(stepVec);
            desired = helpers.resolveCollisionsXZ(desired, this.radius);
          }
        }

        if (input.keys['Space'] && this.grounded) this.velY = this.jumpSpeed;
        const nextY = this.applyVerticalPhysics(dt, desired.x, desired.z);
        this.position.set(desired.x, nextY, desired.z);

        xrRig.position.set(this.position.x, this.position.y - this.eyeHeight, this.position.z);
        if(!input.isXR){ camera.position.set(0, this.eyeHeight, 0); }
      }
    }

    // Helper: obtener forward/right del visor en XR (nivel suelo)
    function getXRHeadBasis() {
      const xrCam = renderer.xr.getCamera(camera);
      const baseCam = (xrCam && xrCam.isArrayCamera && xrCam.cameras && xrCam.cameras.length)
        ? xrCam.cameras[0]
        : xrCam;
      const fwd = new THREE.Vector3();
      baseCam.getWorldDirection(fwd);
      fwd.y = 0; fwd.normalize();
      const right = fwd.clone().applyAxisAngle(new THREE.Vector3(0,1,0), Math.PI/2);
      return { fwd, right };
    }

    class VRPlayer extends PlayerBase {
      update(dt){
        const { THREE, renderer, camera, input, helpers, xrRig } = this.env;
        const session = renderer.xr.getSession();
        if(!session){ return; }

        if(!xrSources.left && !xrSources.right) bindXRInputSources();
        const leftGp  = xrSources.left?.gamepad || null;
        const rightGp = xrSources.right?.gamepad || null;

        let lx = getAxisSafe(leftGp,  2, 0);
        let ly = getAxisSafe(leftGp,  3, 1);
        let rx = getAxisSafe(rightGp, 2, 0);

        const dead=0.1, turnDead=0.25;
        if(Math.abs(lx)<dead) lx=0;
        if(Math.abs(ly)<dead) ly=0;
        if(Math.abs(rx)<turnDead) rx=0;

        // Usar orientación del rig (yaw del jugador), no la cabeza, para locomoción
        const dir = new THREE.Vector3(0,0,-1).applyQuaternion(xrRig.quaternion); dir.y=0; dir.normalize();
        const right = new THREE.Vector3(1,0,0).applyQuaternion(xrRig.quaternion); right.y=0; right.normalize();

        if(!axisSign.calibrated && (Math.abs(lx)>0.6 || Math.abs(ly)>0.6)){
          const testF = dir.clone().multiplyScalar(-ly);
          axisSign.y = (testF.dot(dir) >= 0) ? 1 : -1;
          const testS = right.clone().multiplyScalar(lx);
          axisSign.x = (testS.dot(right) >= 0) ? 1 : -1;
          axisSign.calibrated = true;
        }

        const base = this.speed;
        let move = new THREE.Vector3();
        move.addScaledVector(dir,   axisSign.y * (-ly));
        move.addScaledVector(right, axisSign.x * ( lx));

        if(move.lengthSq()>1e-6){
          move.normalize().multiplyScalar(base*dt);
          // Subdivide movement to robustify collision in VR
          let desired = this.position.clone();
          const steps = Math.max(1, Math.ceil(move.length() / (this.radius*0.5)));
          const stepVec = move.clone().multiplyScalar(1/steps);
          for(let i=0;i<steps;i++){
            desired.add(stepVec);
            desired = helpers.resolveCollisionsXZ(desired, this.radius);
          }
          const nextY = this.applyVerticalPhysics(dt, desired.x, desired.z);
          this.position.set(desired.x, nextY, desired.z);
        } else {
          const groundY = helpers.getGroundHeightAt(this.position.x, this.position.z);
          this.velY -= this.gravity*dt;
          let nextY = this.position.y + this.velY*dt;
          if (nextY - this.eyeHeight <= groundY){ nextY = groundY + this.eyeHeight; this.velY=0; this.grounded=true; } else this.grounded=false;
          this.position.y = nextY;
        }

        if(rx!==0){
          const turnSpeed = 1.6;
          yawRigAroundViewer(-rx * turnSpeed * dt);
        }

        this.syncRig();
      }
    }

    const env = {
      THREE,
      scene,
      camera,
      renderer,
      xrRig,
      input,
      helpers: { resolveCollisionsXZ, getGroundHeightAt, getCeilingHeightAt }
    };

    let player = new DesktopPlayer(env);
    xrRig.position.set(player.position.x, player.position.y - player.eyeHeight, player.position.z);
    camera.position.set(0, player.eyeHeight, 0);

    const controllerState = { update: (dt)=>player.update(dt), enabled:true };

    document.addEventListener('keydown', e=>{ input.keys[e.code]=true; emit('key:down', e); if(e.code==='KeyR') loadHSML(); });
    document.addEventListener('keyup',   e=>{ input.keys[e.code]=false; emit('key:up', e); });

    // Unificador de "usar"
    function emitUseFromPointer(source, ctrl=null){
      let hit = null;
      if (input.isXR){
        hit = (ctrl ? pickFromController(ctrl) : null) || pickFromController(xrCtrl1) || pickFromController(xrCtrl2) || pickCenter();
      } else {
        hit = pickCenter();
      }
      emit('input:use', { source, hit });
    }

    canvas.addEventListener('mousedown', ()=>{ if (document.pointerLockElement!==canvas) canvas.requestPointerLock(); emitUseFromPointer('mouse'); emitTouchFromPointer('mouse'); });
    try { canvas.addEventListener('touchstart', ()=>{ emitUseFromPointer('touch'); emitTouchFromPointer('touch'); }, { passive: true }); }
    catch(_) { canvas.addEventListener('touchstart', ()=>{ emitUseFromPointer('touch'); emitTouchFromPointer('touch'); }); }
    document.addEventListener('pointerlockchange', ()=>{ input.pointerLocked = (document.pointerLockElement===canvas); document.getElementById('toggleFreeCameraBtn').textContent = input.pointerLocked ? 'Liberar Mouse' : 'Capturar Mouse'; });
    document.addEventListener('mousemove', e=>{ if(input.isXR) return; if(!input.pointerLocked) return; yaw -= e.movementX*mouseSensitivity; pitch -= e.movementY*mouseSensitivity; const maxP=Math.PI/2-0.001; if(pitch>maxP)pitch=maxP; if(pitch<-maxP)pitch=-maxP; camera.quaternion.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ')); emit('mouse:look', {yaw,pitch}); });

    // Físicas/colliders
    const staticColliders = [];
    function addBoxColliderFor(obj, size){
      const handle = {
        object: obj, vnode: null,
        min: new THREE.Vector3(), max: new THREE.Vector3(),
        half: new THREE.Vector3(size.x/2, size.y/2, size.z/2),
        recalcHalf(){},
        __id: Math.random().toString(36).slice(2)
      };
      const center = obj.getWorldPosition(new THREE.Vector3());
      handle.min.set(center.x - handle.half.x, center.y - handle.half.y, center.z - handle.half.z);
      handle.max.set(center.x + handle.half.x, center.y + handle.half.y, center.z + handle.half.z);
      staticColliders.push(handle); 
      return handle;
    }
    function updateColliderAABBs(){
      for(const c of staticColliders){
        // Usar AABB real del objeto en mundo para respetar rotaciones/escala
        const box = new THREE.Box3().setFromObject(c.object);
        // Inflar en Y para planos (tienen grosor geométrico ~0)
        if (c.vnode && String(c.vnode.tag).toLowerCase()==='plane'){
          const thick = parseFloat(c.vnode.attributes?.thickness ?? 0.1);
          box.min.y -= thick/2;
          box.max.y += thick/2;
        }
        c.min.copy(box.min);
        c.max.copy(box.max);
      }
    }
    function getGroundHeightAt(x,z){ let gy = -Infinity; for(const c of staticColliders){ if(x>=c.min.x && x<=c.max.x && z>=c.min.z && z<=c.max.z){ gy = Math.max(gy, c.max.y); } } return (gy===-Infinity)? 0 : gy; }
    function getCeilingHeightAt(x,z){ let cy = Infinity; for(const c of staticColliders){ if(x>=c.min.x && x<=c.max.x && z>=c.min.z && z<=c.max.z){ cy = Math.min(cy, c.min.y); } } return cy; }
    function resolveCollisionsXZ(pos, r){
      let p = pos.clone();
      for(let iter=0; iter<4; iter++){
        let moved = false;
        for(const c of staticColliders){
          const min=c.min, max=c.max;
          const insideX = (p.x>min.x && p.x<max.x);
          const insideZ = (p.z>min.z && p.z<max.z);
          if(insideX && insideZ){
            // Empujar hacia el lado más cercano, dejando un margen r
            const dl = p.x - min.x, dr = max.x - p.x, db = p.z - min.z, df = max.z - p.z;
            const m = Math.min(dl, dr, db, df);
            const eps = 1e-3;
            if (m===dl)      p.x = min.x - r - eps;
            else if(m===dr)  p.x = max.x + r + eps;
            else if(m===db)  p.z = min.z - r - eps;
            else             p.z = max.z + r + eps;
            moved = true; continue;
          }
          // Empuje circular alrededor de bordes/esquinas
          const closestX=Math.max(min.x, Math.min(p.x, max.x));
          const closestZ=Math.max(min.z, Math.min(p.z, max.z));
          const dx=p.x-closestX, dz=p.z-closestZ;
          const d2=dx*dx+dz*dz, rr=r*r;
          if(d2<rr){ const d=Math.sqrt(Math.max(d2,1e-6)); const nx=dx/d, nz=dz/d; const push=(r-d)+1e-3; p.x+=nx*push; p.z+=nz*push; moved=true; }
        }
        if(!moved) break;
      }
      return p;
    }

    function fpsCharacterController(dt){
      const forward = new THREE.Vector3(0,0,-1).applyEuler(new THREE.Euler(0,yaw,0,'YXZ'));
      const right   = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), forward).normalize();
      let move = new THREE.Vector3();
      const base = player.speed * ( (input.keys['ShiftLeft']||input.keys['ShiftRight']) ? player.sprintMult : 1 );
      if(input.keys['KeyW']) move.add(forward);
      if(input.keys['KeyS']) move.addScaledVector(forward,-1);
      if(input.keys['KeyA']) move.addScaledVector(right,-1);
      if(input.keys['KeyD']) move.add(right);
      if (move.lengthSq()>1e-6) move.normalize().multiplyScalar(base*dt);

      // Horizontal + colisiones XZ
      let desired = player.position.clone().add(move);
      desired = resolveCollisionsXZ(desired, player.radius);

      // Salto/gravedad
      const groundY = getGroundHeightAt(desired.x, desired.z);
      if (input.keys['Space'] && player.grounded) player.velY = player.jumpSpeed;
      player.velY -= player.gravity * dt;
      let nextY = player.position.y + player.velY * dt;

      if (nextY - player.eyeHeight <= groundY){
        nextY = groundY + player.eyeHeight;
        player.velY = 0;
        player.grounded = true;
      } else player.grounded = false;

      const ceil = getCeilingHeightAt(desired.x, desired.z);
      if (ceil < Infinity && nextY >= ceil - 1e-3){
        nextY = Math.min(nextY, ceil - 1e-3);
        if (player.velY>0) player.velY = 0;
      }

      player.position.set(desired.x, nextY, desired.z);
      // actualizar rig/cámara
      xrRig.position.set(player.position.x, player.position.y - player.eyeHeight, player.position.z);
      if(!input.isXR){ camera.position.set(0, player.eyeHeight, 0); }
    }

    // ----------------- VR: entrada y locomoción -----------------
    const xrSources = { left:null, right:null };
    const axisSign = { x: 1, y: 1, calibrated: false }; // autocalibra signos

    function bindXRInputSources(){
      const session = renderer.xr.getSession();
      if(!session) return;
      const refresh = ()=>{
        xrSources.left = xrSources.right = null;
        for (const src of session.inputSources){
          if(!src || !src.gamepad) continue;
          if(src.handedness==='left')  xrSources.left  = src;
          if(src.handedness==='right') xrSources.right = src;
        }
      };
      refresh();
      session.addEventListener('inputsourceschange', refresh);
    }

    function getAxisSafe(gp, ixPrimary, ixAlt){
      if(!gp || !gp.axes) return 0;
      const a = gp.axes;
      if(a.length>ixPrimary && a[ixPrimary]!==undefined) return a[ixPrimary];
      if(a.length>ixAlt     && a[ixAlt]    !==undefined) return a[ixAlt];
      return 0;
    }

    const tmpV = new THREE.Vector3();
    const Y_UP = new THREE.Vector3(0,1,0);

    function yawRigAroundViewer(deltaYaw){
      if(Math.abs(deltaYaw) < 1e-6) return;
      const camXR = renderer.xr.getCamera(camera);
      const eyeWorld = new THREE.Vector3().setFromMatrixPosition(camXR.matrixWorld);
      const t1 = new THREE.Matrix4().makeTranslation(-eyeWorld.x, 0, -eyeWorld.z);
      const r  = new THREE.Matrix4().makeRotationY(deltaYaw);
      const t2 = new THREE.Matrix4().makeTranslation( eyeWorld.x, 0,  eyeWorld.z);
      xrRig.applyMatrix4(t2.multiply(r).multiply(t1));
    }

    function vrCharacterController(dt){
      const session = renderer.xr.getSession();
      if(!session) return;

      const leftGp  = xrSources.left?.gamepad || null;
      const rightGp = xrSources.right?.gamepad || null;

      // Ejes (índices primarios y fallback)
      let lx = getAxisSafe(leftGp,  2, 0);
      let ly = getAxisSafe(leftGp,  3, 1);
      let rx = getAxisSafe(rightGp, 2, 0);

      // Deadzones
      const dead=0.18, turnDead=0.3;
      if(Math.abs(lx)<dead) lx=0;
      if(Math.abs(ly)<dead) ly=0;
      if(Math.abs(rx)<turnDead) rx=0;

      // Dirección del HMD (cabeza-relativo)
      const xrCam = renderer.xr.getCamera(camera);
      const baseCam = (xrCam && xrCam.isArrayCamera && xrCam.cameras && xrCam.cameras.length) ? xrCam.cameras[0] : xrCam;
      const dir = new THREE.Vector3(); baseCam.getWorldDirection(dir); dir.y=0; dir.normalize();
      const right = dir.clone().applyAxisAngle(new THREE.Vector3(0,1,0), Math.PI/2);

      // Autocalibración de signo (una vez)
      if(!axisSign.calibrated && (Math.abs(lx)>0.6 || Math.abs(ly)>0.6)){
        // Espera que empujar "adelante" avance hacia dir (dot > 0)
        const testF = dir.clone().multiplyScalar(-ly);
        axisSign.y = (testF.dot(dir) >= 0) ? 1 : -1;
        // Espera que empujar "derecha" desplace hacia right (dot > 0)
        const testS = right.clone().multiplyScalar(lx);
        axisSign.x = (testS.dot(right) >= 0) ? 1 : -1;
        axisSign.calibrated = true;
      }

      // Movimiento
      const base = player.speed;
      let move = new THREE.Vector3();
      move.addScaledVector(dir,   axisSign.y * (-ly));
      move.addScaledVector(right, axisSign.x * ( lx));

      if(move.lengthSq()>1e-6){
        move.normalize().multiplyScalar(base*dt);
        let desired = player.position.clone().add(move);
        desired = resolveCollisionsXZ(desired, player.radius);

        // Gravedad
        const groundY = getGroundHeightAt(desired.x, desired.z);
        player.velY -= player.gravity * dt;
        let nextY = player.position.y + player.velY*dt;
        if (nextY - player.eyeHeight <= groundY){ nextY = groundY + player.eyeHeight; player.velY = 0; player.grounded=true; } else player.grounded=false;

        const ceil = getCeilingHeightAt(desired.x, desired.z);
        if(ceil < Infinity && nextY >= ceil - 1e-3){
          nextY = Math.min(nextY, ceil - 1e-3);
          if(player.velY>0) player.velY=0;
        }
        player.position.set(desired.x, nextY, desired.z);
      } else {
        // Solo gravedad
        const groundY = getGroundHeightAt(player.position.x, player.position.z);
        player.velY -= player.gravity*dt;
        let nextY = player.position.y + player.velY*dt;
        if (nextY - player.eyeHeight <= groundY){ nextY = groundY + player.eyeHeight; player.velY=0; player.grounded=true; } else player.grounded=false;
        player.position.y = nextY;
      }

      // Giro suave con stick derecho (alrededor del visor)
      if(rx!==0){
        const turnSpeed = 1.6; // rad/s
        yawRigAroundViewer(-rx * turnSpeed * dt);
      }

      // Aplicar pose del jugador al rig
      xrRig.position.set(player.position.x, player.position.y - player.eyeHeight, player.position.z);
    }

    // ----------------- Raycast / "usar" -----------------
    const raycaster = new THREE.Raycaster();
    function firstVirtualHit(hits){
      if(!hits||!hits.length) return null;
      for(const h of hits){
        let o=h.object;
        while(o){ if(o.userData && o.userData.key){ return { object:h.object, point:h.point, distance:h.distance }; } o=o.parent; }
      }
      // Fallback: retorna el primer hit aunque no tenga userData.key
      const h0 = hits[0];
      return { object:h0.object, point:h0.point, distance:h0.distance };
    }
    function pickCenter(far=100){
      raycaster.far = far;
      if(input.isXR){
        const xrCam = renderer.xr.getCamera(camera);
        raycaster.ray.origin.setFromMatrixPosition(xrCam.matrixWorld);
        raycaster.ray.direction.set(0,0,-1).transformDirection(xrCam.matrixWorld);
        const hits=raycaster.intersectObjects(scene.children,true);
        return firstVirtualHit(hits);
      } else {
        raycaster.setFromCamera({x:0,y:0}, camera);
        const hits=raycaster.intersectObjects(scene.children,true);
        return firstVirtualHit(hits);
      }
    }

    const controllerModelFactory = new XRControllerModelFactory();
    const tempMatrix = new THREE.Matrix4();
    function buildXRRay(data){
      if (data.targetRayMode === 'tracked-pointer'){
        const geom = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1) ]);
        const mat = new THREE.LineBasicMaterial({ transparent:true, opacity:0.8 });
        return new THREE.Line(geom, mat);
      } else if (data.targetRayMode === 'gaze'){
        const geom = new THREE.RingGeometry(0.02, 0.04, 32).translate(0,0,-1);
        const mat = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, transparent:true, opacity:0.5 });
        return new THREE.Mesh(geom, mat);
      }
      return new THREE.Group();
    }
    function pickFromController(ctrl, far=100){
      tempMatrix.identity().extractRotation(ctrl.matrixWorld);
      raycaster.far = far;
      raycaster.ray.origin.setFromMatrixPosition(ctrl.matrixWorld);
      raycaster.ray.direction.set(0,0,-1).applyMatrix4(tempMatrix);
      const hits = raycaster.intersectObjects(scene.children,true);
      const h = firstVirtualHit(hits);
      if (h) return h;
      return null;
    }

    const xrCtrl1 = renderer.xr.getController(0);
    const xrCtrl2 = renderer.xr.getController(1);
    [xrCtrl1, xrCtrl2].forEach((ctrl)=>{
      ctrl.addEventListener('connected', (e)=>{
        ctrl.userData.handedness = e.data.handedness;
        ctrl.add(buildXRRay(e.data));
      });
      ctrl.addEventListener('disconnected', ()=>{
        while(ctrl.children.length) ctrl.remove(ctrl.children[0]);
      });
      // disparan el mismo "usar" y también 'toque' con pick desde el controlador
      ctrl.addEventListener('selectstart', ()=>{ emitUseFromPointer('vr', ctrl); emitTouchFromPointer('vr', ctrl); });
      ctrl.addEventListener('select',      ()=>{ emitUseFromPointer('vr', ctrl); emitTouchFromPointer('vr', ctrl); });
      xrRig.add(ctrl);
    });
    const grip1 = renderer.xr.getControllerGrip(0); grip1.add(controllerModelFactory.createControllerModel(grip1)); xrRig.add(grip1);
    const grip2 = renderer.xr.getControllerGrip(1); grip2.add(controllerModelFactory.createControllerModel(grip2)); xrRig.add(grip2);

    // ----------------- Toque (desktop y VR) -----------------
    // Desktop: click/touch en el centro lanza 'toque' con pickCenter
    function emitTouchFromPointer(source, ctrl=null){
      const hit = ctrl ? pickFromController(ctrl) : pickCenter();
      if(!hit) return;
      const v = findVNodeFromObject(hit.object);
      if (v) emitToNode('toque', v, { source, object: hit.object, point: hit.point, distance: hit.distance });
      else emit('toque', { source, object: hit.object, point: hit.point, distance: hit.distance });
    }
    // Los listeners de mousedown/touchstart principales disparan esto también

    // VR: colisión del controlador contra mallas (esfera-pequeña contra AABB del objeto)
    const touchingByCtrl = new Map([[xrCtrl1, new Set()], [xrCtrl2, new Set()]]);
    function getCtrlTip(ctrl){ const v=new THREE.Vector3(); v.setFromMatrixPosition(ctrl.matrixWorld); return v; }
    function forEachMesh(callback){ scene.traverse(obj=>{ if(obj.isMesh){ callback(obj); } }); }
    function checkVRTouches(){
      if(!input.isXR) return;
      const controllers=[xrCtrl1,xrCtrl2];
      const radius=0.035;
      for(const ctrl of controllers){ if(!ctrl) continue; const tip=getCtrlTip(ctrl); const touching=touchingByCtrl.get(ctrl) || new Set(); const current=new Set();
        forEachMesh(mesh=>{
          const box = new THREE.Box3().setFromObject(mesh);
          const dist = box.distanceToPoint(tip);
          if(dist <= radius){
            current.add(mesh.uuid);
            if(!touching.has(mesh.uuid)){
              emit('toque', { source:'vr', object: mesh, point: tip.clone(), controller: ctrl });
            }
          }
        });
        touchingByCtrl.set(ctrl, current);
      }
    }

    renderer.xr.addEventListener('sessionstart', ()=>{
      input.isXR = true;
      axisSign.x = 1; axisSign.y = 1; axisSign.calibrated = false;
      player = new VRPlayer(env);
      controllerState.update = (dt)=>player.update(dt);
      bindXRInputSources();
      camera.position.set(0, 0, 0); // en XR, la altura la pone el HMD
      player.syncRig();
      xrRig.rotation.set(0,0,0);
    });
    renderer.xr.addEventListener('sessionend',   ()=>{
      input.isXR = false;
      axisSign.x = 1; axisSign.y = 1; axisSign.calibrated = false;
      player = new DesktopPlayer(env);
      controllerState.update = (dt)=>player.update(dt);
      xrRig.rotation.set(0,0,0);
      camera.position.set(0, player.eyeHeight, 0);
    });

    // ----------------- Loop principal -----------------
    renderer.setAnimationLoop(animate);
    function animate(){ 
      const now=performance.now(); 
      const dt=(now-lastFrameTS)/1000; 
      lastFrameTS=now; 

      userUpdateFunctions.forEach(fn=>{ try{ fn(dt); }catch(e){ console.error('update error', e); } });

      if(virtualDOM) applyTransformsRecursively(virtualDOM);
      updateColliderAABBs();

      if(controllerState.enabled && controllerState.update) controllerState.update(dt);
      // detectar 'toque' en VR por proximidad del controlador
      checkVRTouches();

      updateStats(now); 
      maybeUpdateDevTool(); 
      renderer.render(scene,camera); 
    }

    function updateStats(now){ frames++; if(now-lastTimeStat>=1000){ currentFPS = frames*1000/(now-lastTimeStat); frames=0; lastTimeStat=now; document.getElementById('fpsValue').textContent=currentFPS.toFixed(1); if(performance.memory){ const used=(performance.memory.usedJSHeapSize/1048576).toFixed(1); const total=(performance.memory.totalJSHeapSize/1048576).toFixed(1); document.getElementById('ramValue').textContent=`${used} / ${total} MB`; } } }

    // ----------------- API pública (dimension) -----------------
    const dimension = {
      createElement: (tag)=>createProxiedNode(tag),
      create(tag, attrs={}, children=[]) { const node=createProxiedNode(tag); Object.entries(attrs).forEach(([k,v])=>node.setAttribute(k,v)); children.forEach(ch=>node.appendChild(ch)); return node; },
      appendChild(child){ if(!virtualDOM){ console.warn('No virtualDOM'); return; } virtualDOM.children.push(child); buildSceneFromVirtual(child, scene); scheduleDevToolUpdate(); },
      remove(nodeOrId){ let v=(typeof nodeOrId==='string')? idToVNode.get(nodeOrId): nodeOrId; if(!v) return; removeNodeByKey(virtualDOM, v.key); const obj=nodeKeyToObject.get(v.key); if(obj&&obj.parent) obj.parent.remove(obj); nodeKeyToObject.delete(v.key); scheduleDevToolUpdate(); },
      find(selector){ if(!selector) return []; if(selector.startsWith('#')){ const v=idToVNode.get(selector.slice(1)); return v ? [createProxiedNode(v)] : []; } if(selector.startsWith('.')){ const set=classToVNodes.get(selector.slice(1)); return set ? Array.from(set).map(v=>createProxiedNode(v)) : []; } const out=[]; (function walk(v){ if(!v) return; if(v.tag===selector) out.push(createProxiedNode(v)); (v.children||[]).forEach(walk); })(virtualDOM); return out; },
      getObjectFor(nodeOrId){ let v=(typeof nodeOrId==='string')? idToVNode.get(nodeOrId): nodeOrId; if(!v) return null; return nodeKeyToObject.get(v.key)||null; },
      behavior(name,factory){ behaviorRegistry.set(name, factory); },
      refresh(){ scheduleDevToolUpdate(); },
      toHSML(){ return serializeHSML(virtualDOM); },
      importHSML(hsml){ importHSMLFromString(hsml); },

      on, off, emit,

      loop: { onUpdate(fn){ userUpdateFunctions.add(fn); return ()=>userUpdateFunctions.delete(fn); }, offUpdate(fn){ userUpdateFunctions.delete(fn); } },

      input: {
        isDown(code){ return !!input.keys[code]; },
        pointerLocked: ()=>input.pointerLocked,
        lockPointer(){ if(document.pointerLockElement!==canvas) canvas.requestPointerLock(); },
        unlockPointer(){ if(document.pointerLockElement===canvas) document.exitPointerLock(); },
        onUse(cb){ on('input:use', cb); return ()=>off('input:use', cb); }
      },

      camera: {
        teleport(x,y,z){ 
          player.position.set(x,y??player.eyeHeight,z);
          xrRig.position.set(player.position.x, player.position.y - player.eyeHeight, player.position.z);
          if(!input.isXR){ 
            camera.position.set(0, player.eyeHeight, 0);
          } else {
            player.syncRig();
          }
        },
        setYawPitch(yawRad,pitchRad){ yaw=yawRad; pitch=pitchRad; if(!input.isXR){ camera.quaternion.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ')); } },
        getYawPitch(){ return { yaw, pitch }; },
        getPosition(){ return camera.getWorldPosition(new THREE.Vector3()); }
      },
      controller: {
        enable(v){ controllerState.enabled=!!v; },
        set(fn){ controllerState.update = fn; controllerState.enabled = true; }
      },

      physics: {
        addBoxCollider: addBoxColliderFor,
        clearColliders,
        resolvePlayerXZ: (desired, r)=>resolveCollisionsXZ(desired, r??player.radius),
        getGroundHeightAt,
        pickCenter: (far)=>pickCenter(far),
        pickFromController: (i=0, far=100)=>{ const ctrl=[xrCtrl1,xrCtrl2][i]; if(!ctrl) return null; return pickFromController(ctrl, far); }
      },

      audio: { play: playSoundOneShot, attachPositional: attachPositionalAudio },

      // Helpers para scripts HSML (evitan manejar proxies directamente)
      get(id){ const v=idToVNode.get(id); return v ? createProxiedNode(v) : null; },
      setAttr(id, name, value){ const v=idToVNode.get(id); if(!v) return; v.setAttribute(name, value); scheduleDevToolUpdate(); },

      state: globalState,
      math: MATH
    };

    const behaviorRegistry = new Map();
    function setUpdate(fn){ userUpdateFunctions.add(fn); }
    function serializeHSML(vnode){ if(!vnode) return ''; const attrs=Object.entries(vnode.attributes).map(([k,v])=>`${k}="${String(v)}"`).join(' '); const open=attrs?`<${vnode.tag} ${attrs}>`:`<${vnode.tag}>`; if(!vnode.children||vnode.children.length===0) return `${open}</${vnode.tag}>`; return `${open}${vnode.children.map(serializeHSML).join('')}</${vnode.tag}>`; }

    // (Sin lógica de demo aquí; la demo vive dentro de DEFAULT_HSML)

    // ----------------- Carga HSML -----------------
    async function loadHSML(){
      const inputEl=document.getElementById('urlInput');
      const input=inputEl?inputEl.value.trim():'';
      let hsml='';
      const hashLevel=new URLSearchParams(location.hash.replace('#','')).get('level');
      if(!input && hashLevel){
        try{ const res=await fetch(hashLevel); hsml=await res.text(); }
        catch(e){ console.warn('No se pudo cargar hash level, usando demo'); hsml=DEFAULT_HSML; }
      } else if (!input && !hashLevel){
        // Preferir "inicio" guardado en localStorage si existe
        let home='';
        try{ home = localStorage.getItem('hsml:home') || ''; }catch(_){ home=''; }
        if(home){
          if(inputEl) inputEl.value = home;
          if(home.trim().startsWith('<')){ hsml = home; }
          else {
            try{ const res=await fetch(home); hsml=await res.text(); }
            catch(e){ console.warn('No se pudo cargar HOME, usando demo'); hsml=DEFAULT_HSML; }
          }
        } else {
          hsml = DEFAULT_HSML;
        }
      } else if (input && input.startsWith('<')){
        hsml=input;
      } else if (input){
        try{ const res=await fetch(input); hsml=await res.text(); }
        catch(e){ console.warn('No se pudo cargar URL, usando demo'); hsml=DEFAULT_HSML; }
      } else {
        hsml=DEFAULT_HSML;
      }
      await importHSMLFromString(hsml);
    }

    async function importHSMLFromString(hsml){
      if (typeof hsml === 'string') { hsml = hsml.replace(/<\\\/script>/g, '<\/script>'); }
      scene.children.slice().forEach(obj=>{ const keep = (obj===gridHelper)||(obj===axesHelper)||(obj===ambientLight)||(obj===dirLight)||(obj===xrRig); if(!keep) scene.remove(obj); });
      nodeKeyToObject.clear(); VirtualNode.nextKey=1; userUpdateFunctions.clear(); clearColliders();

      const parsed = parseHSMLRootFromString(hsml);
      if(!parsed || !parsed.vnode){ console.error('No <hsml> o <space> root'); return; }
      virtualDOM = parsed.vnode; reindexVirtualDOM(); await buildSceneFromVirtual(virtualDOM, scene); scheduleDevToolUpdate();

      // Ejecutar scripts (inline, src o code="...")
      const xml = new DOMParser().parseFromString(hsml, 'text/xml');
      let scriptNodes = [];
      const hsmlEl = xml.getElementsByTagName('hsml')[0] || null;
      if (hsmlEl){
        scriptNodes = Array.from(hsmlEl.getElementsByTagName('script'));
      } else {
        const spaceEl = xml.getElementsByTagName('space')[0] || null;
        if (spaceEl) scriptNodes = Array.from(spaceEl.getElementsByTagName('script'));
      }
      if (scriptNodes.length){
        for (let i=0;i<scriptNodes.length;i++){
          const node=scriptNodes[i];
          const src=node.getAttribute('src');
          const codeAttr=node.getAttribute('code');
          const inline=(node.textContent||'').trim();
          if(src){ fetch(src).then(r=>r.text()).then(code=>runSandbox(code)).catch(err=>console.error('Script load error',src,err)); }
          else if(codeAttr && codeAttr.trim()) { runSandbox(codeAttr); }
          else if(inline){ runSandbox(inline); }
        }
      }

      applyTransformsRecursively(virtualDOM);
      updateColliderAABBs();

      // Spawn del jugador: meta spawn o centro del <space> root
      const metaSpawn = (parsed && parsed.meta && parsed.meta.spawn) ? parsed.meta.spawn : null;
      const rootX = parseFloat(virtualDOM?.attributes?.x ?? 0) || 0;
      const rootZ = parseFloat(virtualDOM?.attributes?.z ?? 0) || 0;
      const sx = (metaSpawn && metaSpawn.x !== undefined) ? metaSpawn.x : rootX;
      const sy = (metaSpawn && metaSpawn.y !== undefined) ? metaSpawn.y : player.eyeHeight;
      const sz = (metaSpawn && metaSpawn.z !== undefined) ? metaSpawn.z : rootZ;
      player.position.set(sx, sy, sz);
      const gy = getGroundHeightAt(player.position.x, player.position.z);
      if (player.position.y - player.eyeHeight < gy) { player.position.y = gy + player.eyeHeight; }
      player.velY=0; player.grounded=false; 
      xrRig.position.set(player.position.x, player.position.y - player.eyeHeight, player.position.z);
      if(!input.isXR){ camera.position.set(0, player.eyeHeight, 0); yaw = (metaSpawn && metaSpawn.yaw !== undefined) ? metaSpawn.yaw : 0; pitch = (metaSpawn && metaSpawn.pitch !== undefined) ? metaSpawn.pitch : 0; camera.quaternion.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ')); }
    }

    // Track last HSML source to support sandbox navigation-like behavior
    let lastHSMLSource = null; // { type: 'url'|'string', value: string }
    function sandboxNavigate(url, replace=false){
      try{
        const urlInputEl = document.getElementById('urlInput');
        if (url && url.trim().startsWith('<')){
          lastHSMLSource = { type:'string', value:url };
          importHSMLFromString(url);
          return;
        }
        if (!url) return;
        if (urlInputEl) urlInputEl.value = url;
        try{ const hash = '#level='+encodeURIComponent(url); if(replace) history.replaceState({}, '', hash); else history.pushState({}, '', hash); }catch(_){ /* ignore history errors */ }
        fetch(url).then(r=>r.text()).then(txt=>{ lastHSMLSource = { type:'url', value:url }; importHSMLFromString(txt); }).catch(e=>console.error('Sandbox navigate error', url, e));
      }catch(e){ console.error('sandboxNavigate error', e); }
    }

    function runSandbox(code){
      try {
        const sandboxLocation = {
          get href(){ return window.location.href; },
          set href(v){ sandboxNavigate(String(v)); },
          assign(v){ sandboxNavigate(String(v), false); },
          replace(v){ sandboxNavigate(String(v), true); },
          reload(){ if(!lastHSMLSource) return; if(lastHSMLSource.type==='url'){ sandboxNavigate(lastHSMLSource.value, true); } else { importHSMLFromString(lastHSMLSource.value); } }
        };
        const fn=new Function('dimension','setUpdate','setTimeout','setInterval','location', code);
        fn(dimension, setUpdate, setTimeout, setInterval, sandboxLocation);
      } catch(err){
        console.error('HSML <script> error:', err);
      }
    }

    // Ejecuta un script con overlay temporal en dimension.state (para includes con data-*)
    function runSandboxWithState(code, stateOverlay){
      const backup = new Map();
      if (stateOverlay && typeof stateOverlay === 'object'){
        for (const k of Object.keys(stateOverlay)){
          backup.set(k, Object.prototype.hasOwnProperty.call(dimension.state, k) ? dimension.state[k] : Symbol.for('@@__unset'));
          dimension.state[k] = stateOverlay[k];
        }
      }
      try{
        runSandbox(code);
      } finally {
        if (backup.size){
          for (const [k, v] of backup.entries()){
            if (v === Symbol.for('@@__unset')) delete dimension.state[k]; else dimension.state[k] = v;
          }
        }
      }
    }

    // ----------------- UI Eventos -----------------
    document.getElementById('loadButton').addEventListener('click', loadHSML);
    document.getElementById('reloadBtn').addEventListener('click', loadHSML);
    document.getElementById('exportBtn').addEventListener('click', ()=>{ const text=dimension.toHSML(); const blob=new Blob([text], {type:'application/xml'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='scene.hsml'; a.click(); URL.revokeObjectURL(url); });
    const devPanel=document.getElementById('devPanel'); const toggleDevPanelBtn=document.getElementById('toggleDevPanel'); toggleDevPanelBtn.addEventListener('click',()=>{ if(devPanel.style.display==='none' || devPanel.style.display===''){ devPanel.style.display='block'; } else { devPanel.style.display='none'; } });
    const inspectorView=document.getElementById('inspectorView'); const statusView=document.getElementById('statusView');
    document.getElementById('inspectorTabBtn').addEventListener('click',()=>{ inspectorView.style.display='block'; statusView.style.display='none'; });
    document.getElementById('statusTabBtn').addEventListener('click',()=>{ inspectorView.style.display='none'; statusView.style.display='block'; });
    document.getElementById('toggleFreeCameraBtn').addEventListener('click',()=>{ if(document.pointerLockElement!==canvas) canvas.requestPointerLock(); else document.exitPointerLock(); });
    document.getElementById('toggleLightingBtn').addEventListener('click',()=>{ lightingEnabled=!lightingEnabled; if(lightingEnabled){ if(!scene.children.includes(ambientLight)) scene.add(ambientLight); if(!scene.children.includes(dirLight)) scene.add(dirLight); } else { scene.remove(ambientLight); scene.remove(dirLight); } });
    document.getElementById('toggleGridBtn').addEventListener('click',()=>{ gridHelper.visible=!gridHelper.visible; axesHelper.visible=gridHelper.visible; });
    document.getElementById('urlInput').addEventListener('keydown', (e)=>{ if(e.key==='Enter') loadHSML(); });

    // --------- Favoritos / Inicio / Opciones ---------
    const LS_FAVS = 'hsml:favorites';
    const LS_HOME = 'hsml:home';
    const favAddBtn = document.getElementById('favAddBtn');
    const favList   = document.getElementById('favList');
    const favGoBtn  = document.getElementById('favGoBtn');
    const homeGoBtn = document.getElementById('homeGoBtn');
    const homeSetBtn= document.getElementById('homeSetBtn');
    const optionsBtn= document.getElementById('optionsBtn');
    const optionsPanel=document.getElementById('optionsPanel');
    const homeInput = document.getElementById('homeInput');
    const homeSaveBtn=document.getElementById('homeSaveBtn');
    const optionsCloseBtn=document.getElementById('optionsCloseBtn');

    function loadFavs(){ try{ return JSON.parse(localStorage.getItem(LS_FAVS)||'[]'); }catch(_){ return []; } }
    function saveFavs(arr){ try{ localStorage.setItem(LS_FAVS, JSON.stringify(arr)); }catch(_){ } }
    function renderFavs(){ const favs=loadFavs(); if(favList){ favList.innerHTML=''; favs.forEach((f)=>{ const opt=document.createElement('option'); opt.value=f; opt.textContent=f; favList.appendChild(opt); }); } }
    function addFav(v){ if(!v||!v.trim()) return; const favs=loadFavs(); if(!favs.includes(v)) { favs.push(v); saveFavs(favs); renderFavs(); } }

    if(favAddBtn) favAddBtn.addEventListener('click', ()=>{ const v=document.getElementById('urlInput').value.trim(); if(v) addFav(v); });
    if(favGoBtn) favGoBtn.addEventListener('click', ()=>{ const v=favList.value; if(v){ document.getElementById('urlInput').value=v; loadHSML(); }});
    if(favList) favList.addEventListener('dblclick', ()=>{ const v=favList.value; if(v){ document.getElementById('urlInput').value=v; loadHSML(); }});

    function getHome(){ try{ return localStorage.getItem(LS_HOME)||''; }catch(_){ return '';} }
    function setHome(v){ try{ localStorage.setItem(LS_HOME, v||''); }catch(_){ } }
    if(homeGoBtn) homeGoBtn.addEventListener('click', ()=>{ const v=getHome(); if(v){ document.getElementById('urlInput').value=v; loadHSML(); }});
    if(homeSetBtn) homeSetBtn.addEventListener('click', ()=>{ const v=document.getElementById('urlInput').value.trim(); if(v){ setHome(v); if(homeInput) homeInput.value=v; }});
    if(optionsBtn) optionsBtn.addEventListener('click', ()=>{ if(!optionsPanel) return; optionsPanel.style.display = (optionsPanel.style.display==='none'||optionsPanel.style.display==='')? 'block':'none'; if(homeInput) homeInput.value=getHome(); });
    if(homeSaveBtn) homeSaveBtn.addEventListener('click', ()=>{ if(!homeInput) return; setHome(homeInput.value.trim()); if(optionsPanel) optionsPanel.style.display='none'; });
    if(optionsCloseBtn) optionsCloseBtn.addEventListener('click', ()=>{ if(optionsPanel) optionsPanel.style.display='none'; });

    renderFavs();

    // ----------------- Demo por defecto mínima -----------------
const DEFAULT_HSML = `
<space>
  <light type="ambient" intensity="0.7" />
  <light type="directional" intensity="1.2" />
  <group id="world">
    <plane id="floor" width="200" height="200" color="#2a2a2a" y="0" thickness="0.1" />
    <box id="wall1" width="8" height="2" depth="0.6" color="#546e7a" x="-4" y="1" z="-6" collider="true" />
    <box id="wall2" width="8" height="2" depth="0.6" color="#546e7a" x=" 4" y="1" z="-6" collider="true" />
    <box id="centerCube" width="1" height="1" depth="1" color="#4db6ac" x="0" y="0.5" z="0" class="spin" />
  </group>
  <script>
    const cubeNode = dimension.get('centerCube');
    let _centerCubeToggle=false;
    cubeNode.addEventListener('toque', ({target})=>{
      if(!target) return;
      const color = _centerCubeToggle ? '#4db6ac' : '#ff7043';
      target.setAttribute('color', color);
      _centerCubeToggle=!_centerCubeToggle;
    });
  <\/script>
</space>`;


    // Carga inicial
    loadHSML();
  </script>
</body>
</html>
